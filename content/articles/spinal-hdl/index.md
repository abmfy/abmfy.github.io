---
title: "Weekly9::é€ å°è®¡ç®—æœºï¼Œä½†æ˜¯ SpinalHDL + Verilator"
date: 2024-05-11T15:00:00+08:00
tags: [SpinalHDL, Verilator]
summary: ä½¿ç”¨ SpinalHDL + Verilator è¿›è¡Œé«˜æ•ˆæ•°å­—é€»è¾‘å¼€å‘
---

æœ¬æ–‡å‡è®¾ä½ å¯¹æ•°å­—é€»è¾‘ç”µè·¯çš„åŸºæœ¬çŸ¥è¯†æœ‰ä¸€å®šçš„äº†è§£ï¼Œä¾‹å¦‚æ­£åœ¨æˆ–å·²ç»é€‰ä¿®ã€Šæ•°å­—é€»è¾‘ç”µè·¯ã€‹æˆ–ã€Šæ•°å­—é€»è¾‘è®¾è®¡ã€‹è¯¾ç¨‹ï¼Œäº†è§£ç»„åˆé€»è¾‘ä¸æ—¶åºé€»è¾‘çš„åŒºåˆ«ã€‚å¦‚æœä½ æ­£åœ¨é€‰ä¿®ã€Šæ•°å­—é€»è¾‘è®¾è®¡ã€‹è¯¾ç¨‹ï¼Œè¿˜æ˜¯æŒºå»ºè®®å­¦ä¸€å­¦ SpinalHDL çš„ï¼Œå¯ä»¥æå¤§æå‡ä½ çš„æ•°è®¾ç”Ÿæ´»ä½“éªŒã€‚

å¦‚æœä½ å·²ç»æˆ–è€…æ­£åœ¨é€‰ä¿®ã€Šæ•°å­—é€»è¾‘å®éªŒã€‹ã€Šè®¡ç®—æœºç»„æˆåŸç†ã€‹ç­‰è¯¾ç¨‹ï¼Œä½ å¾ˆå¯èƒ½ä¼šä½¿ç”¨ VHDL æˆ–è€… SystemVerilog è¯­è¨€è¿›è¡Œç¡¬ä»¶æè¿°ï¼Œå¹¶é€šè¿‡ Quartus æˆ– Vivado ç­‰ EDA (Electronic Design Automation, ç”µå­è®¾è®¡è‡ªåŠ¨åŒ–) å·¥å…·è¿›è¡Œç¡¬ä»¶è®¾è®¡çš„ç»¼åˆã€‚

ç„¶è€Œï¼ŒEDA å·¥å…·è‡ªå¸¦çš„ç¼–è¾‘å™¨å¾€å¾€éš¾ä»¥ä½¿ç”¨ï¼Œä¸”ç¼ºä¹ç°ä»£ IDE å…·æœ‰çš„è‡ªåŠ¨è¡¥å…¨ã€å¼•ç”¨è·³è½¬ã€è¯­æ³•æ£€æŸ¥ç­‰åŠŸèƒ½ã€‚é€šè¿‡ VS Code ç­‰ç¼–è¾‘å™¨çš„æ’ä»¶èƒ½å¤Ÿéƒ¨åˆ†å¼¥è¡¥ä¸Šè¿°ç¼ºé™·ï¼Œä½†åœ¨åŒæ­¥æ—¶åºç”µè·¯è®¾è®¡ä¸­ååˆ†å…³é”®çš„é”å­˜å™¨æ£€æŸ¥ã€è¿ç®—æ•°å®½åº¦æ£€æŸ¥ã€æ¨¡å—è¾“å…¥è¾“å‡ºç«¯å£æ£€æŸ¥ä¸Šï¼ŒVivado ç­‰å·¥å…·å¾€å¾€åªä¼šç»™å‡ºè­¦å‘Šï¼Œè€Œè¿™äº›è­¦å‘Šä¼šæ·¹æ²¡åœ¨æ•°ç™¾ä¸ªå¸¸è§„è­¦å‘Šä¸­ï¼Œé€ æˆéš¾ä»¥é¢„æ–™çš„é”™è¯¯ã€‚

å¦å¤–ï¼Œè¿™äº›ä¼ ç»Ÿç¡¬ä»¶æè¿°è¯­è¨€çš„è®¾è®¡æ—¶é—´éƒ½ç›¸å½“æ—©ï¼šVHDL ä¸ Verilog è®¾è®¡äº 1983 å¹´ï¼Œå³ä½¿æ˜¯è¾ƒæ–°çš„ SystemVerilog ä¹Ÿå§‹äº 2002 å¹´ï¼Œå¹¶ä¸”å¤šæ•° EDA å·¥å…·å¯¹ SystemVerilog çš„æ”¯æŒå¹¶ä¸å®Œå¤‡ã€‚è¿™å¯¼è‡´åœ¨ç¼–å†™ç¡¬ä»¶æè¿°ä»£ç æ—¶ï¼Œéœ€è¦ç¼–å†™å¤§é‡çš„æ¨¡æ¿ä»£ç ï¼Œä¾‹å¦‚çŠ¶æ€æœºã€‚æ¥çº¿ä¹Ÿæ˜¯é¥±å—è¯Ÿç—…çš„ä¸€ç‚¹ï¼šåœ¨ã€Šæ•°å­—é€»è¾‘å®éªŒã€‹çš„åŠ æ³•å™¨å®éªŒä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨æŠŠå„ä¸ªé—¨ç”µè·¯çš„è¾“å…¥è¾“å‡ºç«¯å£ç”¨å¯¼çº¿è¿æ¥èµ·æ¥ï¼Œå½¢å¦‚ä¸‹å›¾ï¼š

![023B9BD0-391B-440E-82B7-81774F699AC4_1_105_c](adder.png)

åœ¨ SystemVerilog ä¸­ï¼Œä½ åŒæ ·éœ€è¦åšç±»ä¼¼çš„äº‹æƒ…ï¼Œç”¨ä¸€ä¸ªä¸­é—´ä¿¡å·è¿›è¡Œä¸­è½¬ï¼Œå°†ä¸€ä¸ªæ¨¡å—çš„è¾“å…¥ä¸å¦ä¸€ä¸ªæ¨¡å—çš„è¾“å‡ºè¿æ¥ã€‚å¯¹äºåƒ Wishbone æ€»çº¿è¿™æ ·æœ‰å¤šä¸ªä¿¡å·ï¼Œè€Œä¸”éœ€è¦å¤šå¤„è¿æ¥çš„åœ°æ–¹ï¼Œå…‰æ˜¯è¿›è¡Œæ¥çº¿æœ¬èº«å°±å·²ç»ååˆ†ç—›è‹¦äº†ï¼Œæ›´ä½•å†µä½ éœ€è¦è¿›è¡Œç»¼åˆåï¼Œæ‰èƒ½åœ¨ Vivado ç»™å‡ºçš„æ•°ç™¾ä¸ªè­¦å‘Šä¸­å‘ç°æ¥çº¿æ—¶å¶ç„¶çš„ typoâ€”â€”

**å†™é”™éƒ¨åˆ†ä¿¡å·åå­—å¹¶ä¸ä¼šå¯¼è‡´ç»¼åˆå¤±è´¥ï¼Œå³ä½¿ä¿¡å·çš„ç±»å‹éƒ½å¯¹ä¸ä¸Šï¼**

ä»¥ä¸‹æ˜¯ä¸€ä¸ª Wishbone å¤šè·¯å¤ç”¨å™¨çš„æ¥çº¿ä¾‹å­ï¼š

```verilog
// Wishbone MUX
wb_mux_3 wb_mux_3_inst (
    .clk(sys_clk),
    .rst(sys_rst),

    // Master interface
    .wbm_adr_i(wbs_adr_o),
    .wbm_dat_i(wbs_dat_o),
    .wbm_dat_o(wbs_dat_i),
    .wbm_we_i(wbs_we_o),
    .wbm_sel_i(wbs_sel_o),
    .wbm_stb_i(wbs_stb_o),
    .wbm_ack_o(wbs_ack_i),
    .wbm_err_o(),
    .wbm_rty_o(),
    .wbm_cyc_i(wbs_cyc_o),

    // Slave interface 0 (to BaseRAM controller)
    // Address range: 0x8000_0000 ~ 0x803F_FFFF
    .wbs0_addr    (32'h8000_0000),
    .wbs0_addr_msk(32'hFFC0_0000),

    .wbs0_adr_o,
    .wbs0_dat_i,
    .wbs0_dat_o,
    .wbs0_we_o,
    .wbs0_sel_o,
    .wbs0_stb_o,
    .wbs0_ack_i,
    .wbs0_err_i(0),
    .wbs0_rty_i(0),
    .wbs0_cyc_o,

    // Slave interface 1 (to ExtRAM controller)
    // Address range: 0x8040_0000 ~ 0x807F_FFFF
    .wbs1_addr    (32'h8040_0000),
    .wbs1_addr_msk(32'hFFC0_0000),

    .wbs1_adr_o,
    .wbs1_dat_i,
    .wbs1_dat_o,
    .wbs1_we_o,
    .wbs1_sel_o,
    .wbs1_stb_o,
    .wbs1_ack_i,
    .wbs1_err_i(0),
    .wbs1_rty_i(0),
    .wbs1_cyc_o,

    // Slave interface 2 (to UART controller)
    // Address range: 0x1000_0000 ~ 0x1000_FFFF
    .wbs2_addr    (32'h1000_0000),
    .wbs2_addr_msk(32'hFFFF_0000),

    .wbs2_adr_o,
    .wbs2_dat_i,
    .wbs2_dat_o,
    .wbs2_we_o,
    .wbs2_sel_o,
    .wbs2_stb_o,
    .wbs2_ack_i,
    .wbs2_err_i(0),
    .wbs2_rty_i(0),
    .wbs2_cyc_o
);
```

è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ª SystemVerilog çš„å°æŠ€å·§ï¼Œå³æ¥çº¿ç«¯å£å’Œä¿¡å·çš„åå­—å¦‚æœä¸€æ ·ï¼Œåˆ™å¯ä»¥çœç•¥ä¿¡å·åå­—ã€‚å³ä¾¿åœ¨ä»Šå¤©ï¼Œä½ å¯ä»¥åˆ©ç”¨ Copilot å¿«é€Ÿè¡¥å…¨è¿™äº›é‡å¤ä»£ç ï¼Œæ¥çº¿é”™è¯¯ä»ç„¶ä¼šå¸¦æ¥è®¸å¤šéš¾ä»¥æ’æŸ¥çš„é—®é¢˜ã€‚

ç°åœ¨å‡è®¾ä½ å·²ç»é¡ºåˆ©ç¼–å†™äº†è¯­æ³•æ­£ç¡®çš„ç¡¬ä»¶æè¿°ä»£ç ï¼Œåœ¨ä¸Šæ¿æµ‹è¯•ä¹‹å‰ï¼Œä½ è¿˜æœ‰é‡è¦çš„ä¸€æ­¥â€”â€”ä»¿çœŸã€‚ä»¿çœŸèƒ½å¤Ÿå¿«é€Ÿåœ°éªŒè¯è®¾è®¡çš„æ­£ç¡®æ€§ï¼Œæ›´é‡è¦çš„æ˜¯é€šè¿‡ä»¿çœŸï¼Œæˆ‘ä»¬å¯ä»¥è·å¾—æ¯ä¸ªä¿¡å·æ¯ä¸€æ—¶åˆ»çš„å–å€¼ï¼Œä»è€Œå¿«é€Ÿæ’æŸ¥é—®é¢˜ã€‚ç„¶è€Œï¼ŒVivado çš„ä»¿çœŸé€Ÿåº¦å®åœ¨ä¸æ•¢æ­ç»´ï¼ŒåŒæ—¶è¿˜å­˜åœ¨ç€æ·»åŠ ä¿¡å·éœ€è¦é‡æ–°ä»¿çœŸç­‰ç­‰é—®é¢˜ã€‚åœ¨è¿›è¡Œè¾ƒå°è§„æ¨¡çš„å¼€å‘æ—¶ï¼Œä¹Ÿè®¸è¿™å¹¶ä¸æ˜¯é—®é¢˜ï¼Œä½†å¦‚æœä½ è¦å¯¹ä½ çš„ CPU è®¾è®¡è¿›è¡Œ uCore å¯åŠ¨è¿‡ç¨‹çš„ä»¿çœŸï¼Œè¿™å¯èƒ½ä¼šæ¶ˆè€—æ‰æ•°åå°æ—¶çš„æ—¶é—´ï¼Œè¿™æ˜¯ä¸å¯æ¥å—çš„ã€‚

åæ§½äº†è¿™ä¹ˆå¤šä¼ ç»Ÿç¡¬ä»¶æè¿°è¯­è¨€å¼€å‘ä¸ä»¿çœŸæµç¨‹ä¸­çš„ç—›ç‚¹ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±è¦ä»‹ç»ä»Šå¤©çš„ä¸»è§’â€”â€”SpinalHDL äº†ã€‚

> æœ¬æ–‡ä¸­æ²¡æœ‰é‚£ä¹ˆé‡è¦çš„è¯ä¼šåœ¨è¿™ç§æ ¼å¼çš„å¼•ç”¨å—é‡Œå‡ºç°ã€‚

## SpinalHDL

[SpinalHDL](https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Introduction/SpinalHDL.html) æ˜¯ä¸€ç§æ›´é«˜å±‚æ¬¡çš„ç¡¬ä»¶æè¿°è¯­è¨€ï¼ŒåŸºäº Scalaã€‚æœ¬è´¨ä¸Šï¼ŒSpinalHDL åªæ˜¯ Scala çš„ä¸€ä¸ªç¬¬ä¸‰æ–¹åº“ï¼Œå¹¶ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„ä¸€é—¨æ–°çš„è¯­è¨€ã€‚SpinalHDL ä¹Ÿå¹¶ä¸èƒ½å¤Ÿç›´æ¥è¢« EDA å·¥å…·ç»¼åˆï¼Œè€Œæ˜¯é€šè¿‡ç¼–è¯‘åˆ° VHDLã€Verilog æˆ– SystemVerilog ç­‰è¾ƒä½å±‚æ¬¡è¯­è¨€çš„æ–¹å¼è¿›è¡Œç»¼åˆã€‚è¿™æœ‰ç‚¹ç±»ä¼¼äºé«˜çº§ç¨‹åºè¯­è¨€ç¼–è¯‘åˆ°æ±‡ç¼–è¯­è¨€ï¼Œå†ç”±æ±‡ç¼–å™¨æ±‡ç¼–ä¸ºæœºå™¨è¯­è¨€çš„è¿‡ç¨‹ã€‚

![SpinalHDL Workflow](flow.png)

## å®‰è£…

ç”±äº SpinalHDL åªæ˜¯ä¸€ä¸ª Scala åº“ï¼Œå®ƒçš„å®‰è£…ç›¸å½“ç®€å•â€”â€”ä½¿ç”¨ä½ çš„åŒ…ç®¡ç†å™¨æ·»åŠ  `spinalhdl-core` ä¸ `spinalhdl-lib` ä½œä¸ºä¾èµ–å³å¯ï¼Œå‰è€…æ˜¯ SpinalHDL çš„æ ¸å¿ƒè¯­è¨€åŠŸèƒ½ï¼Œåè€…æ˜¯ SpinalHDL æä¾›çš„ä¼—å¤šå·¥å…·åº“ã€‚

ç­‰ç­‰ï¼Œä½ è¯´ä½ è¿˜ä¸ä¼š Scalaï¼Ÿæ²¡æœ‰å…³ç³»ï¼ç¬”è€…åŒæ ·æ˜¯åœ¨å­¦ä¹  SpinalHDL çš„è¿‡ç¨‹ä¸­å­¦ä¹  Scala çš„ã€‚è€ƒè™‘åˆ°è®¡ç®—æœºç³»çš„ä¸“ä¸šè¯¾ä¸­åŸºæœ¬æ²¡æœ‰ç”¨ä¸Š Scala çš„æœºä¼šï¼Œæœ¬æ–‡å°†ä¼šé€æ­¥è¦†ç›–åˆ° SpinalHDL ä¸­ä½¿ç”¨åˆ°çš„ Scala è¯­æ³•ã€‚äº‹å®ä¸Šï¼Œç»è¿‡è®¡ç®—æœºç³»çš„æ‹·æ‰“ï¼Œç›¸ä¿¡è¯»è€…å·²ç»å‘ç°é™¤äº†è¯­è¨€ç¥ Rustï¼Œå­¦ä¹ ä¸€é—¨æ–°ç¼–ç¨‹è¯­è¨€çš„æˆæœ¬æ˜¯å¾ˆä½çš„ï¼Œå°¤å…¶æ˜¯åœ¨ä½ å·²ç»ä¼šäº† C++ è¿™ç§å¾‹å¸ˆç‹‚å–œè¯­è¨€ä¹‹åã€‚

æ€»ç»“ä¸€ä¸‹ï¼Œæˆ‘ä»¬ä¸€å…±éœ€è¦å®‰è£…ä¸‹åˆ—ç¯å¢ƒï¼š

- [JDK](https://www.oracle.com/java/technologies/downloads/) (Java Development Kit)ã€‚Scala ä¸ Java, Kotlin ç­‰è¯­è¨€ç±»ä¼¼ï¼Œè¿è¡Œäº Java è™šæ‹Ÿæœºä¹‹ä¸Šï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ JDK è¿›è¡Œå¼€å‘ã€‚
- [Scala](https://www.scala-lang.org) 2ã€‚å°½ç®¡ Scala è¿‘æœŸæ¨å‡ºäº†æ–°ç‰ˆæœ¬ Scala 3ï¼Œä½† SpinalHDL å¯¹ Scala 3 çš„é€‚é…ä»åœ¨è¿›è¡Œä¸­ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨ Scala 2ã€‚
- [Mill](https://mill-build.com/mill/Intro_to_Mill.html)ã€‚Scala çš„ä¸€ä¸ªåŒ…ç®¡ç†å™¨ä¸æ„å»ºå·¥å…·ã€‚
- [Verilator](https://www.veripool.org/verilator/)ã€‚SpinalHDL å¯ä»¥é€šè¿‡ Verilator è¿›è¡Œç¡¬ä»¶ä»¿çœŸã€‚

### Windows TL;DR

å¦‚æœä½ æ˜¯ Windows ç”¨æˆ·ï¼Œå¾ˆé—æ†¾ï¼Œç”±äºç¯å¢ƒé…ç½®å®åœ¨å¤ªè¿‡ç¹çï¼ŒSpinalHDL å®˜æ–¹ç›´æ¥ç»™å‡ºäº†ä¸€ä¸ªåŒ…å«ä¸Šè¿°æ‰€æœ‰ç¯å¢ƒçš„ MSYS2 æ‰“åŒ…ï¼Œå¯ä»¥åœ¨ [Readon/msys2-installer](https://github.com/Readon/msys2-installer/releases) ä¸‹è½½ï¼Œå®‰è£…åå¼€ç®±å³ç”¨ã€‚å¦‚æœæ˜¯ macOS æˆ– Linux ç”¨æˆ·ï¼Œè¯·å‚ç…§ä¸‹é¢çš„æŒ‡ç¤ºä¾æ¬¡å®‰è£…ç¯å¢ƒã€‚

### Scala

[Coursier](https://get-coursier.io) æ˜¯ Scala çš„æ¨èç¯å¢ƒç®¡ç†å™¨ï¼Œä½œç”¨ç±»ä¼¼äº Rust è¯­è¨€çš„ [rustup](https://rustup.rs)ï¼Œå¯ä»¥å®‰è£…å’Œç®¡ç† Scala å·¥å…·é“¾ã€‚åŒæ—¶ï¼Œå¦‚æœç¯å¢ƒä¸­æ²¡æœ‰ Java è™šæ‹Ÿæœºï¼ŒCoursier ä¹Ÿä¼šè¿›è¡Œå®‰è£…ã€‚

**Linux x86-64 (AMD64):**

```sh
curl -fL "https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-linux.gz" | gzip -d > cs
chmod +x cs
./cs setup
```

**Linux aarch64 (ARM64):**

```sh
curl -fL "https://github.com/VirtusLab/coursier-m1/releases/latest/download/cs-aarch64-pc-linux.gz" | gzip -d > cs
chmod +x cs
./cs setup
```

**macOS:**

```sh
brew install coursier/formulas/coursier
cs setup
```

è¿™é‡Œçš„ `brew` æ˜¯ [Homebrew](http://brew.sh)ï¼ŒmacOS çš„åŒ…ç®¡ç†å™¨ï¼Œéœ€è¦è‡ªè¡Œå®‰è£…ã€‚é¡ºå¸¦ä¸€æï¼ŒmacOS é¦–å­—æ¯ä¸å¤§å†™ã€‚ä¹Ÿæ²¡æœ‰ç©ºæ ¼ã€‚

### Mill

Scala é»˜è®¤çš„æ„å»ºå·¥å…· [sbt](https://www.scala-sbt.org) å­˜åœ¨è®¸å¤šé—®é¢˜ (å‚è§ [So, what's wrong with SBT?](http://www.lihaoyi.com/post/SowhatswrongwithSBT.html))ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨ [Mill](https://mill-build.com/mill/Intro_to_Mill.html) ä½œä¸ºæ„å»ºå·¥å…·ã€‚

**Linux:**

```sh
sh -c "curl -L https://github.com/com-lihaoyi/mill/releases/download/0.11.7/0.11.7 > ~/.local/bin/mill && chmod +x ~/.local/bin/mill"
```

**macOS:**

```sh
brew install mill
```

### Verilator

**Linux:**

é€šè¿‡åŒ…ç®¡ç†å™¨ä¸€èˆ¬å¯ä»¥ç›´æ¥å®‰è£… Verilatorï¼Œä¾‹å¦‚ä½¿ç”¨ `apt`ï¼š

```sh
apt install verilator
```

å…¶ä»–åŒ…ç®¡ç†å™¨ç‰ˆæœ¬å¯åœ¨ [Verilator package versions](https://repology.org/project/verilator/versions) æ‰¾åˆ°ã€‚

**macOS:**

```sh
brew install verilator
```

### SpinalHDL

SpinalHDL æä¾›äº†[å®˜æ–¹æ¨¡æ¿ä»“åº“](https://github.com/SpinalHDL/SpinalTemplateMill)ï¼Œå¯ä»¥ç›´æ¥å…‹éš†åä½¿ç”¨ã€‚

æˆ‘ä»¬å¯ä»¥çœ‹çœ‹è¯¥ä»“åº“çš„ç»“æ„ï¼š

```
.
â”œâ”€â”€ .editorconfig
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .mill-version
â”œâ”€â”€ README.md
â”œâ”€â”€ build.sc
â””â”€â”€ simple
    â””â”€â”€ src
        â”œâ”€â”€ MyTopLevel.scala
        â””â”€â”€ MyTopLevelSim.scala
```

è¿™é‡Œ `.mill-version` æ˜¯è¦ä½¿ç”¨çš„Mill ç‰ˆæœ¬ï¼Œ`build.sc` æ˜¯ Mill çš„é¡¹ç›®é…ç½®æ–‡ä»¶ï¼Œè€Œ `src` ç›®å½•ä¸‹å°±æ˜¯ SpinalHDL çš„æºæ–‡ä»¶ã€‚

ç”±äºè¿™ä¸ªæ¨¡æ¿ä»“åº“æ¯”è¾ƒè€æ—§ï¼Œä½ å¯èƒ½ä¼šå¸Œæœ›æ›´æ–° Scalaã€ Mill ä¸ SpinalHDL çš„ç‰ˆæœ¬ã€‚

ä¿®æ”¹ `.mill-version` æ–‡ä»¶å†…å®¹ä¸ºç‰ˆæœ¬å·ï¼Œä¾‹å¦‚ï¼š

```
0.11.5
```

å³å¯ä¿®æ”¹ä½¿ç”¨çš„ Mill ç‰ˆæœ¬ã€‚

ä¿®æ”¹ `build.sc` ä¸­ä¸ Scala ä»¥åŠ SpinalHDL ç‰ˆæœ¬ç›¸å…³çš„å‡ å¤„ï¼Œä¾‹å¦‚ï¼š

```diff
--- a/build.sc
+++ b/build.sc
@@ -1,16 +1,18 @@
 // build.sc
 import mill._, scalalib._, publish._
 
+val spinalVersion = "1.9.4"
+
 trait CommonSpinalModule extends ScalaModule {
-  def scalaVersion = "2.12.14"
+  def scalaVersion = "2.12.18"
 
   def scalacOptions = Seq("-unchecked", "-deprecation", "-feature")
 
   def ivyDeps = Agg(
-    ivy"com.github.spinalhdl::spinalhdl-core:1.4.3",
-    ivy"com.github.spinalhdl::spinalhdl-lib:1.4.3",
+    ivy"com.github.spinalhdl::spinalhdl-core:$spinalVersion",
+    ivy"com.github.spinalhdl::spinalhdl-lib:$spinalVersion",
   )
-  def scalacPluginIvyDeps = Agg(ivy"com.github.spinalhdl::spinalhdl-idsl-plugin:1.4.3")
+  def scalacPluginIvyDeps = Agg(ivy"com.github.spinalhdl::spinalhdl-idsl-plugin:$spinalVersion")
 }
 
 object simple extends CommonSpinalModule with PublishModule {
```

å³å¯æ›´æ”¹è¦ä½¿ç”¨çš„ Scala ä¸ SpinalHDL ç‰ˆæœ¬ã€‚ä¸Šé¢ç»™å‡ºçš„ç¤ºä¾‹æ˜¯ç¬”è€…æµ‹è¯•è¿‡çš„ç‰ˆæœ¬ã€‚~~å…¶å®å°±æ˜¯æ‡’å¾—æµ‹è¯•æ›´æ–°ç‰ˆæœ¬äº†ã€‚~~

## Scala åŸºç¡€

è¿™é‡Œé€Ÿé€šä¸€ä¸‹ SpinalHDL éœ€è¦ç”¨åˆ°çš„ Scala åŸºæœ¬è¯­æ³•ã€‚å…¶å®æ²¡æœ‰å¤šå°‘ï¼Œæ¯•ç«Ÿç¡¬ä»¶é€»è¾‘ç”¨ä¸åˆ°é‚£ä¹ˆå¤šæŠ½è±¡ã€‚

ä½ å¯ä»¥é€šè¿‡ `scala` å‘½ä»¤æ‰“å¼€ Scala çš„ REPL (Read-Eval-Print-Loop)  Shell åœ¨å‘½ä»¤è¡Œé‡Œç©ä¸€ç© Scalaã€‚

### åŸºæœ¬ç±»å‹

| ç±»å‹    | å­—é¢é‡          | æè¿°            |
| ------- | --------------- | --------------- |
| Boolean | true, false     |                 |
| Int     | 3, 0x32         | 32 ä½æœ‰ç¬¦å·æ•´æ•° |
| Float   | 3.14f           | å•ç²¾åº¦æµ®ç‚¹æ•°    |
| Double  | 3.14            | åŒç²¾åº¦æµ®ç‚¹æ•°    |
| String  | "Hello, world!" | UTF-16 å­—ç¬¦ä¸²   |

åŸºæœ¬ç±»å‹éƒ½æ˜¯è£…ç®± (boxing) è¿‡çš„ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡ `3.14.abs` è°ƒç”¨ Double çš„ `abs` æ–¹æ³•ã€‚ä½ è¯´æ€ä¹ˆä¸ç”¨æ‹¬å·ï¼Ÿè¿™å°±æ˜¯ Scala çš„ç¥å¥‡ä¹‹å¤„äº†ï¼Œåœ¨å‡½æ•°ä¸ä¼ å‚çš„æŸäº›æƒ…å†µä¸‹å¯ä»¥çœç•¥æ‹¬å·ã€‚

> å…·ä½“è§„åˆ™è¿˜æŒºå¤æ‚çš„ï¼Œå°±åƒ `abs` å…¶å®ä¹Ÿä¸æ˜¯ Double çš„æ–¹æ³•è€Œæ˜¯ [RichDouble](https://scala-lang.org/api/3.x/scala/runtime/RichDouble.html) çš„æ–¹æ³•ä¸€æ ·ï¼Œåªä¸è¿‡ Double èƒ½å¤Ÿéšå¼è½¬æ¢è¿‡å»è€Œå·²ã€‚
>
> Scala ç´ æ¥æœ‰ç³–å°¿ç—…è¯­è¨€ä¹‹ç§° (å¤ªå¤šè¯­æ³•ç³–äº†)ï¼Œå¯¹è¿™äº›ç”¨æ³•ä¸ç”¨å¤ªæ·±ç©¶ï¼Œç›¸ä¿¡å†ç›¸ä¿¡å°±å®Œäº†ã€‚

### å˜é‡

å˜é‡ä½¿ç”¨ `var` å®šä¹‰ï¼Œå¸¸é‡ä½¿ç”¨ `val` å®šä¹‰ã€‚é™æ€ç±»å‹è¯­è¨€ï¼Œå¯ä»¥åŠ ç±»å‹å£°æ˜ä¹Ÿå¯ä»¥è®©ç¼–è¯‘å™¨æ¨æ–­ã€‚

> è¯­å¥ç»“æŸä¸ç”¨åŠ åˆ†å·ï¼Œé™¤éè¦åœ¨ä¸€è¡Œé‡Œå†™å¤šæ¡è¯­å¥ã€‚å¾ˆåƒ Python æ˜¯å§ï¼ŸScala 3 æŠŠå¤§æ‹¬å·ç æ‰äº†ï¼Œä½¿ç”¨ç¼©è¿›åŒºåˆ†åµŒå¥—å±‚çº§ï¼Œæ›´ Python äº†ã€‚

```scala
var number: Int = 0
number = 6
number += 4
println(number) // 10

val two = 2
val three = 3
val six = two * three
```

æœ‰ä¸€ä¸ªåŒæ—¶å£°æ˜å¤šä¸ªå˜é‡çš„è¯­æ³•ï¼Œä¸è¿‡å®ƒä¼šæŠŠè¿™äº›å˜é‡åˆå§‹åŒ–ä¸ºåŒä¸€ä¸ªå€¼ï¼š

```scala
val hello, world = "hello"
println(hello, world) // (hello,hello)
```

å¦‚æœä½ éœ€è¦ç±»ä¼¼ Python é‚£æ ·çš„è¡Œä¸ºï¼Œå¯ä»¥ä½¿ç”¨å…ƒç»„ç»‘å®šï¼š

```scala
val (hello, world) = ("hello", 233)
println(hello, world) // (hello,233)
```

### å‡½æ•°

ä½¿ç”¨ `def` å®šä¹‰å‡½æ•°ã€‚å‡½æ•°çš„æœ€åä¸€æ¡è¯­å¥å°†ä¼šä½œä¸ºè¿”å›å€¼ã€‚

> Rust çš„è¡Œä¸ºä¹Ÿè®¸æ˜¯ä»è¿™é‡Œå€Ÿé‰´çš„ã€‚

```scala
def sumBiggerThanZero(a: Float, b: Float): Boolean = {
    a + b > 0
}
```

å½“ç„¶ï¼Œè¿™é‡Œæœ‰ä¸å°‘ç³–ç³–ï¼š

```scala
// çœç•¥è¿”å›ç±»å‹
def sumBiggerThanZero(a: Float, b: Float) = {
    a + b > 0
}
// çœç•¥å¤§æ‹¬å·
def sumBiggerThanZero(a: Float, b: Float) = a + b > 0
// å‚æ•°é»˜è®¤å€¼
def sumBiggerThanZero(a: Float, b: Float = 0.0f) = a + b > 0
```

æ— è¿”å›å€¼çš„å‚æ•°çš„è¿”å›ç±»å‹æ˜¯ `Unit`ï¼Œå³å•å…ƒç±»å‹ï¼Œç±»ä¼¼ `void`ã€‚äº‹å®ä¸Šå®ƒæœ‰ä¸€ä¸ªå•ä¾‹å€¼ `()`ã€‚

#### å‡½æ•°å¯¹è±¡

å¯¹æ‹¥æœ‰ `apply` æ–¹æ³•çš„å®ä¾‹ (instance)ï¼Œå¯ä»¥åƒè°ƒç”¨å‡½æ•°é‚£æ ·è°ƒç”¨å®ƒä»¬ã€‚ç±»ä¼šåœ¨åé¢æ›´è¯¦ç»†åœ°è®²è§£ã€‚

```scala
class PlusThree {
    def apply(index: Int): Int = index + 3
}
val x = new PlusThree
println(x(4)) // 7
```

### å•ä¾‹ç±»

`object` å…³é”®å­—å¯ä»¥å®šä¹‰ä¸€ä¸ªå•ä¾‹ç±»ï¼Œå…¶ä¸­æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯é™æ€ (static) çš„ï¼Œä¸èƒ½æ‰‹åŠ¨åˆ›å»ºå•ä¾‹ç±»çš„å®ä¾‹ã€‚è¿™ä¸ªæ¦‚å¿µå’Œ Java ä¸­çš„é™æ€ç±»æ¯”è¾ƒç›¸ä¼¼ã€‚

> Java ä¸­å¾ˆå¤šå·¥å…·ç±»å°±å¸¸å¸¸ä»¥é™æ€ç±»çš„å½¢å¼å‡ºç°ï¼Œè€Œä¸”å¸¸å¸¸ä»¥å¤æ•°å½¢å¼å‘½åã€‚ä¾‹å¦‚ `Arrays` æ˜¯æ•°ç»„å·¥å…·çš„é™æ€ç±»ï¼Œé‡Œé¢åŒ…å«å„ç§ä¸æ•°ç»„æ“ä½œæœ‰å…³çš„é™æ€æ–¹æ³•ã€‚

```scala
object MathUtils {
    def pow2(value: Float): Float = value * value
}

MathUtils.pow2(42.0f)
```

### å…¥å£

ä»»ä½•æœ‰ `main` å‡½æ•°çš„å•ä¾‹ç±»éƒ½å¯ä»¥ä½œä¸ºç¨‹åºçš„å…¥å£ã€‚

```scala
object Main {
    def main(args: Array[String]) {
        println("Hello, world!")
    }
}
```

ä¹Ÿå¯ä»¥ç”¨ App ç‰¹è´¨ (trait) æ¥ç®€åŒ–ä¸€ç‚¹ï¼š

> ä¸æ˜¯æˆ‘ç¿»è¯‘çš„ã€‚è¿™æ˜¯ Scala å®˜æ–¹çš„è¯‘åã€‚

```scala
object Main extends App {
    println("Hello, World!")
}
```

### ç±»

æ¯”è¾ƒç‰¹åˆ«çš„ä¸€ç‚¹æ˜¯å±æ€§å†™åœ¨æ‹¬å·é‡Œã€‚

```scala
class Color(r: Float, g: Float, b: Float) {
    def getGrayLevel(): Float = r * 0.3f + g * 0.4f + b * 0.4f
}
val blue = new Color(0, 0, 1)
println(blue.getGrayLevel()) // 0.4
```

é»˜è®¤æƒ…å†µä¸‹å±æ€§éƒ½æ˜¯ç§æœ‰çš„ï¼Œå¦‚æœæƒ³è®©å®ƒä»¬å˜ä¸ºå…¬å¼€å¯ä½¿ç”¨ `val` æˆ– `var` ä¿®é¥°ã€‚

```scala
class Color(val r: Float, val g: Float, val b: Float)
val green = new Color(0, 1, 0)
println(green.g)
```

#### ç»§æ‰¿

å¥½åƒæ²¡ä»€ä¹ˆç‰¹åˆ«çš„ã€‚

```scala
abstract class Shape {
  def getArea(): Float
}

class Square(sideLength: Float) extends Shape {
  override def getArea() = sideLength * sideLength
}

class Rectangle(width: Float, height: Float) extends Shape {
  override def getArea() = width * height
}
```

> è¿™é‡Œ Shape çš„ getArea å‡½æ•°æ²¡æœ‰å®šä¹‰ï¼Œæ‰€ä»¥éœ€è¦æ ‡è®°ä¸ºæŠ½è±¡ç±»ã€‚Java ä¹‹ç±»çš„è¯­è¨€å¾ˆå–œæ¬¢ç©è¿™ä¸€å¥—ã€‚

#### æ ·ä¾‹ç±» (Case Class)

æ›´æ¥è¿‘ç»“æ„ä½“ (struct) æˆ–è€…æ•°æ®ç±» (data class)ï¼Œæä¾›äº†ä¸€äº›åŸºç¡€åŠŸèƒ½ï¼Œä¾‹å¦‚ç›¸ç­‰æ¯”è¾ƒã€å­—ç¬¦ä¸²æ ¼å¼åŒ–ç­‰ã€‚

```scala
case class Rectangle(width: Float, height: Float) extends Shape {
    override def getArea() = width * height
}

println(Rectangle(3, 4) == Rectangle(3, 4)) // true
```

ä½ ä¼šæ³¨æ„åˆ°å‰é¢ä½¿ç”¨ `class` çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨ `new` å…³é”®å­—åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œç„¶è€Œè¿™é‡Œå´ä¸ç”¨ã€‚æ˜¯æ—¶å€™æŠŠå‰é¢æåˆ°çš„ä¸€äº›é›¶ç¢çŸ¥è¯†ç‚¹ä¸²èµ·æ¥äº†â€”â€”å…¶å® `case class` æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªå·¨å¤§è¯­æ³•ç³–ï¼Œç¼–è¯‘å™¨ä¼šå¸®ä½ ç”Ÿæˆä¸€ä¸ªä¸è¿™ä¸ªç±»åŒåçš„ `object`ï¼Œè¿™ä¸ª `object` å®ç°äº† `apply` æ–¹æ³•æ¥åˆ›å»ºå¯¹è±¡ï¼Œå› æ­¤èƒ½å¤Ÿç›´æ¥ä½¿ç”¨æ‹¬å·è°ƒç”¨ã€‚åŒæ—¶ï¼Œç¼–è¯‘å™¨ä¹Ÿä¼šå¸®ä½ å®ç° `equals` ç­‰æ–¹æ³•ã€‚å¦å¤–ï¼Œ`case class` çš„å±æ€§é»˜è®¤éƒ½æ˜¯å…¬å¼€çš„ã€‚

ä¸ºä»€ä¹ˆä¼šå« `case class` è¿™ä¸ªåå­—å‘¢ï¼Ÿå› ä¸º `case class` è¿˜å®ç°äº† `unapply` æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ç”¨äºåœ¨æ¨¡å¼åŒ¹é…ä¸­å°†ä¸€ä¸ªå¯¹è±¡â€œæ‹†è§£â€ä¸ºå…¶ä¸­çš„å±æ€§ï¼Œä½¿å¾—å®ƒèƒ½å¤Ÿä½œä¸º `match` è¯­å¥çš„ `case`ï¼Œä¾‹å¦‚ï¼š

```scala
sealed trait Notification

case class Email(sender: String, title: String, body: String) extends Notification

case class SMS(caller: String, message: String) extends Notification

case class VoiceRecording(contactName: String, link: String) extends Notification
```

è¿™é‡Œæˆ‘ä»¬ç”¨åˆ°äº†ç‰¹è´¨ traitï¼Œå®ƒç±»ä¼¼äº Java ä¸­çš„æ¥å£ (interface) æˆ– Python ä¸­çš„åè®® (Protocol)ã€‚`sealed` å…³é”®å­—æŒ‡æ˜è¿™ä¸ªç‰¹è´¨åªèƒ½åœ¨åŒä¸€æ–‡ä»¶ä¸­è¢«å®ç°ï¼Œå®é™…ä¸Šä¿è¯äº†å¯ä»¥ç©·ä¸¾è¿™ä¸€ç‰¹è´¨çš„æ‰€æœ‰å®ç°ã€‚

```scala
def showNotification(notification: Notification): String = {
  notification match {
    case Email(sender, title, _) =>
      s"You got an email from $sender with title: $title"
    case SMS(number, message) =>
      s"You got an SMS from $number! Message: $message"
    case VoiceRecording(name, link) =>
      s"You received a Voice Recording from $name! Click the link to hear it: $link"
  }
}
val someSms = SMS("12345", "Are you there?")
val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")

println(showNotification(someSms))  // prints You got an SMS from 12345! Message: Are you there?

println(showNotification(someVoiceRecording))  // prints You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123
```

è¿™é‡Œæˆ‘ä»¬é€šè¿‡å‰é¢å®šä¹‰çš„ `case class` å®ç°ï¼Œå¯ä»¥åœ¨ `match` è¯­å¥è¿›è¡ŒåŒ¹é…å¹¶å–å‡ºå¯¹è±¡çš„å±æ€§ã€‚

>  è¿™é‡Œ `s"...$var..."` æ˜¯å­—ç¬¦ä¸²æ’å€¼è¯­æ³•ï¼Œå³ä½¿ç”¨ `var` å˜é‡çš„å€¼æ›¿ä»£å­—ç¬¦ä¸²ä¸­ `$var` éƒ¨åˆ†ã€‚

### æ³›å‹

ä½¿ç”¨æ–¹æ‹¬å·å£°æ˜æ³›å‹å‚æ•°ã€‚

```scala
class Queue[T] {
    def push(that: T): Unit = ...
    def pop(): T = ...
}
```

å¯ä»¥ä½¿ç”¨ `<:` é™å®šæ³›å‹çš„ç±»å‹ä¸Šç•Œã€‚

```scala
class Queue[T <: Object]
```

è¿™é‡Œçš„ Object æ­£æ˜¯ `java.lang.Object`ï¼ŒScala ä¸º Java æä¾›äº†ä¸€å®šçš„äº’æ“ä½œæ€§ã€‚

Scala å¯¹æ³›å‹çš„å‹å˜ (variance) æœ‰ç€ä¸¥æ ¼çš„è§„å®šï¼Œä¸è¿‡æˆ‘ä»¬å¤§æ¦‚ç‡ç”¨ä¸ä¸Šã€‚

### åŒ…ä¸å¯¼å…¥

åœ¨ä»£ç çš„ç¬¬ä¸€è¡Œå¯ä»¥é€šè¿‡ `package` å…³é”®å­—å£°æ˜å½“å‰æ–‡ä»¶ä¸‹çš„å†…å®¹æ‰€å¤„çš„åŒ…ï¼š

```scala
package cod
```

æœ¬æ–‡çš„ç¤ºä¾‹é»˜è®¤é¡¶å±‚åŒ…ä¸º `cod`ã€‚Scala ä¸ä¾èµ–ç›®å½•å±‚çº§ï¼Œæ‰€ä»¥å¦‚æœæœ‰åµŒå¥—åŒ…ï¼Œéœ€è¦å£°æ˜å®Œæ•´çš„åŒ…ç»“æ„ï¼š

```scala
package cod.lab2
```

å¯¼å…¥è¯­æ³•æ¯”è¾ƒç®€å•ï¼Œå¯ä»¥ä½¿ç”¨ `_` å¯¼å…¥ä¸€ä¸ªåŒ…ä¸‹çš„æ‰€æœ‰å†…å®¹ï¼š

```scala
import spinal.core._
import spinal.lib.io.InOutWrapper
```

### ä»£ç ç”Ÿæˆ

ä½ ä¼šæ³¨æ„åˆ°æˆ‘ä»¬å‰é¢å®Œå…¨æ²¡æœ‰æåˆ° `if`ã€`for` ç­‰ç­‰æ§åˆ¶æµè¯­å¥ã€‚è¿™æ˜¯å› ä¸ºï¼Œåœ¨å†™ SpinalHDL çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ³¨æ„åŒºåˆ†ä¸¤ä¸ªé˜¶æ®µï¼šä»£ç ç”Ÿæˆä¸ç¡¬ä»¶å®é™…æ‰§è¡Œã€‚åœ¨ Verilog ä¸­ï¼Œé€šè¿‡ `if` æˆ‘ä»¬å¯ä»¥æè¿°å½“ä¸€ä¸ªä¿¡å·çš„å€¼ç¬¦åˆè¦æ±‚æ—¶çš„è¡Œä¸ºï¼Œä½† SpinalHDL ä½œä¸º Scala ç¨‹åºï¼Œå®é™…æ‰§è¡Œçš„ä»»åŠ¡æ˜¯ **ç”Ÿæˆ Verilog**ï¼Œå› æ­¤åœ¨å…¶ä¸­çš„ `if` çš„ä½œç”¨æ˜¯æ§åˆ¶ä»£ç ç”Ÿæˆã€‚è‡³äºæè¿°ç¡¬ä»¶è¡Œä¸ºï¼ŒSpinalHDL æä¾›äº†å¦å¤–çš„ä¸€ç³»åˆ—å…³é”®å­— (å®ƒä»¬äº‹å®ä¸Šéƒ½åªæ˜¯ä¸€äº›å‡½æ•°æˆ–å‡½æ•°å¯¹è±¡)ï¼Œæˆ‘ä»¬åœ¨åé¢ä¼šè®²è§£ã€‚

ç°åœ¨åªéœ€è¦è®°ä½ï¼šScala æä¾›çš„ `if` ä¸ `for` æ˜¯ç”¨æ¥æ§åˆ¶ä»£ç ç”Ÿæˆçš„ï¼Œè€Œä¸æ˜¯å®é™…çš„ç¡¬ä»¶é€»è¾‘ã€‚`if` å¸¸ç”¨æ¥è¿›è¡Œæ¡ä»¶ç¼–è¯‘ï¼Œç±»ä¼¼äº Verilog ä¸­çš„ `generate if`ï¼›`for` å¸¸ç”¨æ¥è¿›è¡Œç”Ÿæˆä¸€ç³»åˆ—ç›¸ä¼¼çš„é€»è¾‘ï¼Œç±»ä¼¼äº Verilog ä¸­çš„ `generate for`ã€‚å…·ä½“è¯­æ³•å¾ˆç®€å•ï¼š

```scala
if (config.enableCache) {
    val cache = new Cache(config.cacheConfig)
}
```

```scala
for (i <- 0 to 3) {
    mems(i) = new Mem(config.memConfig)
}
```

è¿™é‡Œ `Cache` ä¸ `Mem` æ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„æ¨¡å—ï¼ŒSpinalHDL ä¸­ä¾‹åŒ–ä¸€ä¸ªæ¨¡å—é€šè¿‡ `new` è¯­æ³•è¿›è¡Œï¼Œæœ¬è´¨ä¸Šå°±æ˜¯æ„é€ ä¸€ä¸ªç±»çš„å®ä¾‹ã€‚

å¥½äº†ï¼ç°åœ¨ä½ å·²ç»æŒæ¡äº†åœ¨ç¼–å†™ SpinalHDL æ—¶éœ€è¦ç”¨åˆ°çš„å¤§å¤šæ•° Scala è¯­æ³•ã€‚å¦‚æœè¿˜æœ‰æ–°çš„è¯­æ³•ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨ä½¿ç”¨æ—¶è¿›è¡Œä»‹ç»ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä¼šé€šè¿‡ã€Šè®¡ç®—æœºç»„æˆåŸç†ã€‹è¯¾ç¨‹çš„å‡ ä¸ªå°å®éªŒæ¥é€æ­¥ä»‹ç» SpinalHDL çš„è¯­æ³•ä¸åŠŸèƒ½ã€‚å³ä½¿ä½ è¿˜æ²¡æœ‰å­¦ä¹ è¿™é—¨è¯¾ç¨‹ä¹Ÿæ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬è®²è§£çš„å†…å®¹å¤šæ•°ä¸éœ€è¦å‰ç½®çŸ¥è¯†ã€‚ä½ ä¹Ÿå¯ä»¥åœ¨[å®éªŒæ–‡æ¡£](https://lab.cs.tsinghua.edu.cn/cod-lab-docs/)é˜…è¯»ç›¸å…³çŸ¥è¯†çš„è®²è§£ã€‚

## å®éªŒ 2: è®¡æ•°å™¨

æˆ‘ä»¬å¸Œæœ›å®ç°ä¸€ä¸ªç®€å•è®¡æ•°å™¨ï¼Œè¾“å…¥ä¿¡å·ä¸ºä¸€ä¸ªè§¦å‘ä¿¡å·ï¼Œè¾“å‡ºä¸ºè®¡æ•°å€¼ï¼Œæ¯æ¬¡è§¦å‘åè®¡æ•°å€¼åŠ  1ã€‚åŒæ—¶ï¼Œè¦æ±‚è®¡æ•°å€¼è¾¾åˆ° 15 åä¸å†å¢é•¿ã€‚

ä»€ä¹ˆï¼Ÿä½ è§‰å¾—è¿™å¤ªç®€å•äº†ï¼Ÿä½ å…ˆåˆ«æ€¥ï¼Œä½¿ç”¨åŠ©æ•™æä¾›çš„æ¡†æ¶è‡ªç„¶ä¸æ€ä¹ˆè´¹åŠ›ï¼Œä½†è¦ç”¨ SpinalHDL æ­ä¸€éæ¡†æ¶å¯æ²¡é‚£ä¹ˆå®¹æ˜“ã€‚è®©æˆ‘ä»¬å¼€å§‹å§ï¼

### æ¨¡å—ä¸åŸºæœ¬è¯­æ³•

æ— è®ºæ˜¯ Verilog è¿˜æ˜¯ SpinalHDL éƒ½å¾ˆå¼ºè°ƒç¡¬ä»¶æ¨¡å—çš„æ¦‚å¿µã€‚æˆ‘ä»¬é€šå¸¸ä¼šå°†ç¡¬ä»¶åˆ’åˆ†ä¸ºä¸€ç³»åˆ—æ¨¡å—ï¼Œè¿™æ ·ä¸€æ¥æ–¹ä¾¿è¿›è¡ŒåŠŸèƒ½çš„åˆ’åˆ†ä¸ç»´æŠ¤ï¼Œå¦ä¸€æ–¹é¢ä¹Ÿæ–¹é¢å¤ç”¨å·²æœ‰ä»£ç ã€‚é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬å¼€å§‹å§ï¼

**Counter.scala**

```scala
package cod.lab2

import spinal.core._

class Counter extends Component {
    val io = new Bundle {
        val trigger = in Bool()
        val count = out UInt(4 bits)
    }

    val counter = Reg(UInt(4 bits)) init(0)
    when (io.trigger) {
        counter := counter +| 1
    }
    io.count := counter
}
```

è¿™é‡Œçš„ `package` è¯­å¥å£°æ˜å½“å‰æ–‡ä»¶æ‰€å±çš„åŒ…ï¼Œç¬¬äºŒè¡Œå¼•å…¥ SpinalHDL çš„æ ¸å¿ƒè¯­è¨€åŠŸèƒ½ã€‚è¿™ä¸¤è¡Œèµ·æ‰‹å¼æœ‰æ—¶è¿˜éœ€è¦åŠ ä¸Š `spinal.lib._` æ¥ä½¿ç”¨ SpinalHDL æä¾›çš„æ›´å¤šè½®å­ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªç»§æ‰¿ `Component` çš„ç±»ï¼Œè¿™å£°æ˜äº†ä¸€ä¸ª SpinalHDL æ¨¡å—ã€‚SpinalHDL æ¨¡å—ä¸­ï¼Œå¸¸å¸¸å£°æ˜ä¸€ä¸ªåä¸º `io` çš„å˜é‡ç»Ÿä¸€å­˜æ”¾è¾“å…¥è¾“å‡ºæ¥å£ã€‚`Bundle` æ˜¯ SpinalHDL æä¾›çš„ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œå¯ä»¥æƒ³è±¡æˆâ€œä¸€æ†â€ä¿¡å·çº¿ï¼Œç”¨äºå®šä¹‰ä¸€ç»„å‘½åä¿¡å·ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬å®šä¹‰äº†ï¼š

- ä¸€ä¸ªåä¸º `trigger` çš„è¾“å…¥ä¿¡å·ï¼Œç±»å‹ä¸º `Bool`ã€‚
- ä¸€ä¸ªåä¸º `count` çš„è¾“å‡ºä¿¡å·ï¼Œç±»å‹ä¸º `UInt`ï¼Œå®½åº¦ä¸º 4 ä½ã€‚

æ³¨æ„è¿™é‡Œçš„ç±»å‹ `Bool` å’Œ `UInt` éƒ½æ˜¯ SpinalHDL æä¾›çš„ä¿¡å·ç±»å‹ï¼Œå¹¶ä¸æ˜¯ Scala çš„å†…ç½®åŸºæœ¬ç±»å‹ `Boolean` ä¸ `Int`ã€‚æœ‰ç¬¦å·ç±»å‹åœ¨ SpinalHDL ä¸­ä¸º `SInt`ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åœ¨æ¨¡å—å†…å®šä¹‰äº†ä¸€ä¸ªåä¸º `counter` çš„å¯„å­˜å™¨ï¼Œç±»å‹ä¸º 4 ä½æ— ç¬¦å·æ•´æ•°ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬é€šè¿‡ `init(0)` å°†å®ƒçš„åˆå§‹å€¼è®¾å®šä¸º 0ã€‚

ä½ å¯ä»¥æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬åœ¨è¿™æ®µä»£ç ä¸­å®Œå…¨æ²¡æœ‰å…³äºæ—¶é’Ÿå’Œå¤ä½ä¿¡å· (clk & reset) ç›¸å…³çš„å£°æ˜ã€‚è¿™æ˜¯å› ä¸º SpinalHDL ä¸“ä¸ºæ•°å­—é€»è¾‘è®¾è®¡ï¼Œå› æ­¤æ¨¡å—é»˜è®¤æ‹¥æœ‰è¿™äº›ç¬¦å·ï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨å¯¹åº”æ—¶é’ŸåŸŸçš„é¡¶å±‚æ¨¡å—å£°æ˜ä¸€æ¬¡å³å¯ï¼Œä¸åƒ Verilog éœ€è¦åœ¨æ¯ä¸ªæ¨¡å—éƒ½è¿›è¡Œå£°æ˜ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ä¸Šé¢ä¸ºå¯„å­˜å™¨è®¾å®šçš„åˆå§‹å€¼å³ä¸ºå¤ä½ä¿¡å·åˆ°æ¥åå¯„å­˜å™¨çš„åˆå§‹å€¼ã€‚

æ¥ä¸‹æ¥çš„ `when` è¯­å¥å—å£°æ˜äº†ä¸€ä¸ªæ¡ä»¶èµ‹å€¼è¯­å¥ï¼Œè¡¨ç¤ºå½“è¾“å…¥çš„ `trigger` ä¿¡å·ä¸ºçœŸæ—¶ï¼Œæ‰§è¡Œè¯­å¥å—ä¸­çš„è¯­å¥ã€‚å†æ¬¡å¼ºè°ƒå’Œ `if` çš„åŒºåˆ«ï¼š`if` æ§åˆ¶ä»£ç ç”Ÿæˆï¼Œè€Œ `when` æè¿°ç¡¬ä»¶è¿è¡Œæ—¶çš„è¡Œä¸ºã€‚

è¯­å¥å—ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† `:=` æ¥å¯¹ä¿¡å·è¿›è¡Œèµ‹å€¼ã€‚`:=` ç›¸å½“äº Verilog ä¸­çš„éé˜»å¡èµ‹å€¼ `<=`ã€‚é˜»å¡èµ‹å€¼æ˜¯ `\=`ï¼Œä½†å®é™…ä¸­å¾ˆå°‘ä½¿ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‡½æ•°ã€å®šä¹‰æ–°ä¿¡å·ç­‰æ–¹å¼æ›´æ¸…æ™°åœ°æè¿°æ„å›¾ã€‚æ³¨æ„ä¿¡å·èµ‹å€¼å¹¶ä¸ä½¿ç”¨ `=`ï¼Œå¥½åœ¨å¦‚æœä½ ä½¿ç”¨ `val` å®šä¹‰å˜é‡ï¼Œç¼–è¯‘å™¨ä¼šé˜»æ­¢ä½ é‡æ–°èµ‹å€¼ã€‚å¯¹äºå¯„å­˜å™¨ï¼Œä¿¡å·èµ‹å€¼çš„ç”Ÿæ•ˆæ—¶æœºä¸ºæ—¶é’Ÿè·³å˜å‘ç”Ÿæ—¶ï¼Œè¿™ä¸€ç‚¹éœ€è¦æ ¼å¤–æ³¨æ„ã€‚å¦‚æœä½ å¯¹ç»„åˆé€»è¾‘ä¸æ—¶åºé€»è¾‘çš„ç†è§£è¿˜ä¸å¤Ÿæ·±åˆ»ï¼Œå¯ä»¥å‚è€ƒã€Šæ•°å­—é€»è¾‘å®éªŒã€‹è¯¾ç¨‹çš„ [ä¸²è¡Œå¯†ç é”å®éªŒæ€è€ƒé¢˜](https://lab.cs.tsinghua.edu.cn/digital-logic-lab/doc/lab7/lab7/#_11)ï¼Œå¯¹ç†è§£è¿™ä¸€åŒºåˆ«æœ‰æå¤§çš„å¸®åŠ©ã€‚

å³ä¾§çš„è¿ç®—ä¸º `counter +| 1`ï¼Œè¡¨ç¤ºé¥±å’ŒåŠ  (saturating add)ï¼Œå³å½“åŠ æ³•ç»“æœè¶…è¿‡æœ€å¤§å€¼æ—¶ï¼Œç›´æ¥è¿”å›æœ€å¤§å€¼ã€‚åœ¨æ²¡æœ‰è¿™ç§è¿ç®—ç¬¦çš„ Verilog ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½è¿˜éœ€è¦ä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼æ¥æè¿°è¿™ç§è¡Œä¸ºï¼Œä½† SpinalHDL æä¾›äº†è®¸å¤šè¿™æ ·çš„è¿ç®—ï¼Œå¯ä»¥å¸®åŠ©ç®€åŒ–å®ç°ã€‚æ™®é€šçš„åŠ æ³•ä½¿ç”¨ `counter + 1` å°±å¯ä»¥äº†ã€‚ä½ å¯ä»¥å‚è€ƒ [Data Types](https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Data%20types/index.html) æŸ¥çœ‹æ¯ä¸ªç±»å‹å®šä¹‰çš„å„ç§è¿ç®—ã€‚

æœ€åï¼Œæˆ‘ä»¬å°†è¾“å‡ºä¿¡å· `count` èµ‹å€¼ä¸ºå†…éƒ¨çš„ `counter` ä¿¡å·ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†è¿™ä¸€è®¡æ•°å™¨æ¨¡å—ã€‚

> è¿™é‡Œæœ‰ä¸å°‘èŠ±å“¨çš„è¯­æ³•ï¼Œæ¯”å¦‚ `in Bool()` äº‹å®ä¸Šæ˜¯è°ƒç”¨äº†ä¸€ä¸ªå« `in` çš„å•ä¾‹ç±»çš„ `Bool()` æ–¹æ³•ã€‚`new` è¡¨è¾¾å¼åé¢è·Ÿç€ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œå®é™…ä¸Šå®šä¹‰äº†ä¸€ä¸ªåŒ¿åå­ç±» (anonymous subclass)ã€‚`when` æ˜¯ä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼Œå®ƒçš„ `apply` æ–¹æ³•æœ‰ä¸¤ä¸ªå‚æ•°åˆ—è¡¨ï¼š`def apply(cond: Bool)(block: => Unit)`ã€‚è¿™é‡Œ `block` è¿˜æ˜¯ä¸€ä¸ªä¼ åå‚æ•° (by-name parameter)ï¼Œå³å»¶è¿Ÿæ±‚å€¼ã€‚`4 bits` é‡Œç”¨äº†éšå¼ç±»å‹è½¬æ¢å°† `Int` è½¬æ¢æˆä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œå¹¶é€šè¿‡åç¼€è¡¨è¾¾å¼è¯­æ³•è°ƒç”¨äº†è¯¥ç±»å‹çš„ `bits` æ–¹æ³•æ¥å®ç°å¸¦å•ä½å­—é¢é‡çš„æ•ˆæœã€‚
>
> ä¸è¿‡å¦‚å‰é¢æ‰€è¯´ï¼Œä¸ç”¨å¤ªæ·±ç©¶è¿™äº›è¯­æ³•ï¼Œä¼šç”¨å°±è¡Œã€‚

### è¾¹æ²¿æ£€æµ‹

æˆ‘ä»¬çŸ¥é“å½“æŒ‰ä¸‹ä¸€ä¸ªæŒ‰é’®æ—¶ï¼Œä¿¡å·å€¼ä¼šæ”¹å˜ã€‚ä½†æˆ‘ä»¬å¸Œæœ›åœ¨â€œæŒ‰ä¸‹â€è¿™ä¸ªç¬é—´è§¦å‘è®¡æ•°å™¨çš„å€¼å¢åŠ ï¼Œè€Œä¸æ˜¯æŒ‰ä¸‹åè®¡æ•°å™¨çš„å€¼ä¸€ç›´å¢åŠ ã€‚æœŸæœ›çš„æ³¢å½¢å¦‚ä¸‹ï¼š

![Lab2 Trigger Wave](lab2-wave.png)

å¦‚æœè¦åœ¨ Verilog ä¸­å®ç°ï¼Œæˆ‘ä»¬å¤§æ¦‚ç‡ä¼šéœ€è¦ä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„å¯„å­˜å™¨æ¥ä¿å­˜ `push_btn` åœ¨ä¸Šä¸ªå‘¨æœŸçš„ä¿¡å·å€¼ï¼Œå¹¶åœ¨æ¯ä¸ªæ—¶é’Ÿå‘¨æœŸåˆ¤æ–­å½“å‰çŠ¶æ€ä¸ä¸Šä¸ªçŠ¶æ€çš„å…³ç³»ã€‚ä½†ä½¿ç”¨ SpinalHDLï¼Œæˆ‘ä»¬åªéœ€è¦ (å­—é¢ä¸Šçš„) ä¸€è¡Œä»£ç å°±èƒ½å®Œæˆè¿™äº›æ“ä½œï¼š

**Trigger.scala**

```scala
class Trigger extends Component {
    val io = new Bundle {
        val push_btn = in Bool()
        val trigger = out Bool()
    }
    io.trigger := RegNext(io.push_btn).rise(initAt = False)
}
```

é¦–å…ˆï¼Œæˆ‘ä»¬é€šè¿‡ `RegNext` å£°æ˜äº†ä¸€ä¸ªé‡‡æ ·å¯„å­˜å™¨ï¼Œè¿™é‡Œå®é™…ä¸Šç­‰åŒäº Verilog ä¸­é¢å¤–å£°æ˜ä¸€ä¸ªå¯„å­˜å™¨æ¥é‡‡æ · `push_btn` ä¸Šä¸ªå‘¨æœŸçš„ä¿¡å·å€¼ã€‚è¿™æ˜¯ç”±äº `push_btn` æ˜¯æ¨¡æ‹Ÿä¿¡å·ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶é‡‡æ ·åæ‰èƒ½ç”¨äºå®é™…çš„æ•°å­—é€»è¾‘ä¹‹ä¸­ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é€šè¿‡  `Bool` ç±»å‹ä¿¡å·çš„ `rise` æ–¹æ³•ï¼Œç”Ÿæˆä¸€ä¸ªæ£€æµ‹é‡‡æ ·ä¿¡å·ä»ä½åˆ°é«˜è·³å˜çš„æ–°ä¿¡å·ï¼Œ`initAt` è¡¨ç¤ºå¤ä½æƒ…å†µä¸‹çš„åˆå§‹å€¼ã€‚æ³¨æ„å¤ä½æ—¶å¯¹äºæœ‰æ˜ç¡®æ„ä¹‰çš„ä¿¡å·è¦ç»™äºˆåˆé€‚çš„åˆå§‹å€¼ï¼Œå¦åˆ™å¯èƒ½åˆšå¤ä½æ—¶ç”±äº `trigger` ä¿¡å·æ„å¤–åœ°ä¸ºé«˜è€Œå¤šè®¡æ•°äº†ä¸€æ¬¡ã€‚

ç±»ä¼¼åœ°è¿˜æœ‰ `fall`ã€`edge` ç­‰æ–¹æ³•ç”¨äºæ£€æµ‹ä»é«˜åˆ°ä½è·³å˜ã€ä»»ä¸€è¾¹æ²¿è·³å˜ã€‚è¿™æ ·ï¼Œå°±å®ç°äº†æ£€æµ‹ `push_btn` ä»ä½åˆ°é«˜è·³å˜çš„æ—¶åˆ»å¹¶ç”Ÿæˆä¸€ä¸ªè„‰å†²ä¿¡å·çš„åŠŸèƒ½ã€‚

è¿™é‡Œ `False` æ˜¯ SpinalHDL æä¾›çš„å­—é¢é‡ï¼Œè¡¨ç¤º `Bool` ç±»å‹ä¿¡å·çš„å‡å€¼ã€‚å®ƒä¸åŒäº `false`ï¼Œè¿™æ˜¯ Scala è¯­è¨€çš„å¸ƒå°”ç±»å‹å­—é¢é‡ã€‚éƒ¨åˆ†åœºæ™¯ä¸‹ï¼Œè¿™ä¸¤ç§ç±»å‹èƒ½å¤Ÿç›¸äº’è½¬æ¢ã€‚

### å¤–éƒ¨æ¨¡å—

SpinalHDL æ”¯æŒé“¾æ¥å¹¶ä½¿ç”¨å…¶ä»–ç¡¬ä»¶æè¿°è¯­è¨€ç¼–å†™çš„å¤–éƒ¨æ¨¡å—ã€‚å®éªŒä»“åº“ä¸­ï¼Œæä¾›äº† Verilog ç¼–å†™çš„æ¨¡å— `SEG7_LUT.v`ã€‚æœ¬ç€é€ è½®å­ä¸å¦‚ç”¨è½®å­çš„åŸåˆ™ï¼Œæˆ‘ä»¬ç›´æ¥åœ¨ SpinalHDL ä¸­å°è£…è¿™ä¸€æ¨¡å—ï¼Œä¹‹åå°±å¯ä»¥åœ¨ SpinalHDL ä¸­æ„‰å¿«åœ°ä½¿ç”¨äº†ï¼š

**Seg7.scala**

```scala
class Seg7 extends BlackBox {
    val io = new Bundle {
        val iDIG = in UInt(4 bits)
        val oSEG1 = out Bits(8 bits)
    }
    noIoPrefix()
    setBlackBoxName("SEG7_LUT")
    addRTLPath("thinpad_top.srcs/sources_1/new/SEG7_LUT.v")
}
```

ä¸å‰é¢ä¸åŒï¼Œ`Seg7` ç»§æ‰¿äº† `BlackBox` ç±»ï¼Œè¡¨æ˜è¿™æ˜¯ä¸€ä¸ªå¤–éƒ¨å®ç°çš„é»‘ç›’æ¨¡å—ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åŒæ ·åœ¨ `io` æ¨¡å—ä¸­å£°æ˜äº†æ¨¡å—çš„è¾“å…¥è¾“å‡ºä¿¡å·ï¼Œè¿™é‡Œæˆ‘ä»¬é‡åˆ°äº†æ–°çš„ä¿¡å·ç±»å‹ `Bits`ã€‚ä¸ Verilog/SV ä¸åŒï¼ŒSpinalHDL ä¸¥æ ¼åŒºåˆ†äº†ç”¨äºç®—æœ¯å’Œé€»è¾‘è¿ç®—çš„ä¿¡å·ç±»å‹ï¼Œå‰è€…ä¸º `UInt` ä¸ `SInt`ï¼Œåè€…ä¸º `Bool` å’Œ `Bits`ï¼Œå®ƒä»¬èƒ½å¤Ÿè¿›è¡Œçš„è¿ç®—å’Œè¯­ä¹‰éƒ½æœ‰æ‰€ä¸åŒã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœä¸€ä¸ªä¿¡å·ä¸ä½œä¸ºæ•°å­¦ä¸Šçš„æ•°å­—è¿›è¡Œè§£é‡Šï¼Œå°±ä½¿ç”¨ `Bits`ã€‚

æ¥ä¸‹æ¥çš„ä¸‰è¡Œä»£ç å°†é»‘ç›’ä¸å¤–éƒ¨æ¨¡å—è¿›è¡Œé“¾æ¥ã€‚é¦–å…ˆæˆ‘ä»¬é€šè¿‡ `noIoPrefix()` å‡½æ•°ç¦ç”¨äº†ä¿¡å·åç§°ä¸­çš„ `io` å‰ç¼€ï¼Œä»¥ä¿è¯å’Œå¤–éƒ¨æ¨¡å—çš„ä¿¡å·åä¸€è‡´ã€‚æ¥ä¸‹æ¥ï¼Œè®¾ç½®è¦é“¾æ¥çš„å¤–éƒ¨æ¨¡å—åä¸º `SEG7_LUT`ã€‚è¿™ä¸€åå­—å¯ä»¥ä¸ SpinalHDL ä¸­çš„æ¨¡å—åä¸åŒï¼Œæœ€åï¼Œé€šè¿‡ `addRTLPath` æŒ‡å®šæ¨¡å—å®é™…å®ç°æ‰€åœ¨çš„ä½ç½®ã€‚

### é¡¶å±‚æ¥å£

å®ç°å®Œå„ä¸ªå­æ¨¡å—åï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé¡¶å±‚æ¨¡å—å°†å„ä¸ªå­æ¨¡å—è¿æ¥åœ¨ä¸€èµ·ã€‚åŒæ—¶ï¼Œé¡¶å±‚æ¨¡å—è¿˜éœ€è¦æ‰¿æ‹…æ•´ä¸ªç¡¬ä»¶ç³»ç»Ÿä¸å¤–éƒ¨ IO æ¥å£çš„è¿æ¥ã€‚

è¿™éƒ¨åˆ†å†…å®¹å‚è€ƒäº† [ä½¿ç”¨ SpinalHDL å®ç° ThinPad æ¨¡æ¿å·¥ç¨‹](https://gycis.me/post/2023-04-09-spinalhdl-thinpad/)ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰éœ€è¦çš„å¤–éƒ¨æ¥å£ã€‚ç”±äºæœ‰äº›æ¥å£åœ¨å®éªŒä¸­æ²¡æœ‰ç”¨ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªé…ç½®ç±»æ¥é…ç½®æ¥å£æ˜¯å¦ç”Ÿæˆï¼š

**Ports.scala**

```scala
package cod

import spinal.core._
import spinal.lib._
import spinal.lib.io._

case class ThinPadIoConfig (
    enableCpldUart: Boolean = false,
    enableBaseRam: Boolean = true,
    enableExtRam: Boolean = true,
    enableUart: Boolean = true,
    enableFlash: Boolean = false,
    enableSl811: Boolean = false,
    enableDm9k: Boolean = false,
    enableVga: Boolean = false,
)
```

è¿™é‡Œæˆ‘ä»¬è¿˜å¼•å…¥äº† `spinal.lib.io._`ï¼Œå…¶ä¸­åŒ…å«äº†ä¸€äº› IO ç›¸å…³çš„åŠŸèƒ½ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é€šè¿‡ç»§æ‰¿ `Bundle` å®šä¹‰æ‰€æœ‰çš„å¤–éƒ¨æ¥å£ã€‚

**Ports.scala**

```scala
case class ThinPadPorts(config: ThinPadIoConfig) extends Bundle {
    val clk_11M0592 = in Bool()
    val push_btn = in Bool()
    val gpio = GpioPorts()
    val uart = config.enableCpldUart generate master(CpldUartPorts())
    val base_ram = config.enableBaseRam generate master(SramPorts())
    val ext_ram = config.enableExtRam generate master(SramPorts())
    val uart0 = config.enableUart generate master(UartPorts())
    val flash = config.enableFlash generate master(FlashPorts())
    val sl811 = config.enableSl811 generate master(Sl811UsbPorts())
    val dm9k = config.enableDm9k generate master(Dm9kEthPorts())
    val video = config.enableVga generate master(VgaPorts())
}
```

é¦–å…ˆï¼Œæˆ‘ä»¬å¿½ç•¥äº† `clk_50M` ä¸ `reset_btn` ä¿¡å·ï¼Œå®ƒä»¬å°†ä¼šä½œä¸ºæ•´ä¸ªç³»ç»Ÿçš„æ—¶é’Ÿä¸å¤ä½ä¿¡å·ä½¿ç”¨ï¼Œç¨åä»‹ç»ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å®šä¹‰äº† `clk_11M0592` ä¸ `push_btn` ä¿¡å·ï¼Œå®ƒä»¬åœ¨å®šä¹‰ä¸Šä¸ä¸€èˆ¬çš„è¾“å…¥ä¿¡å·æ²¡æœ‰åŒºåˆ«ã€‚

ä¹‹åä¸ºäº†ä½¿ç”¨èµ·æ¥æ›´åŠ æ–¹ä¾¿ï¼Œæˆ‘ä»¬å°†ä¸åŒåˆ†ç±»çš„ä¿¡å·ç»„ç»‡ä¸ºä¸€ç³»åˆ—å­å˜é‡ã€‚ä¾‹å¦‚ï¼Œ`GpioPorts` åŒæ ·æ˜¯ `Bundle` çš„å­ç±»ï¼Œè¿™é‡Œæˆ‘ä»¬å°†å­å˜é‡ `gpio` èµ‹å€¼ä¸º `GpioPorts()`ï¼Œä¹‹åå°±å¯ä»¥åœ¨é¡¶å±‚æ¨¡å—ä¸­é€šè¿‡ç±»ä¼¼ `io.gpio.leds` è®¿é—®å…¶ä¸­çš„ä¿¡å·äº†ã€‚

ä¹‹åçš„å£°æ˜è¯­å¥ä¸­ï¼Œ`generate` ä¸ºæ¡ä»¶ç”Ÿæˆï¼Œè¡¨ç¤ºå½“å‰é¢çš„æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œå°†ä¼šç”Ÿæˆåé¢çš„æ¨¡å—ã€‚`master` æŒ‡å®šåé¢çš„ç«¯å£ä½œä¸ºä¸»ç«¯å£ (ç›¸å¯¹äºä»ç«¯å£ `slave`) ç”Ÿæˆï¼Œåé¢å°†ä¼šè¯¦ç»†ä»‹ç»ã€‚

ä¹‹åï¼Œæˆ‘ä»¬ä¾æ¬¡å®šä¹‰å„ç±»ä¿¡å·ï¼š

#### æ™®é€šè¾“å…¥è¾“å‡ºæ¥å£

**Ports.scala**

```scala
case class GpioPorts() extends Bundle {
    val touch_btn = in Bits(4 bits)
    val dip_sw = in Bits(32 bits)
    val leds = out Bits(16 bits)
    val dpy0, dpy1 = out Bits(8 bits)
    setName("")
}
```

è¿™é‡Œæˆ‘ä»¬å®šä¹‰äº†é€šç”¨è¾“å…¥è¾“å‡º (General-Purpose Input/Output) ä¿¡å·ï¼Œå¤šæ•°è¯­æ³•æˆ‘ä»¬å·²ç»è§è¿‡ï¼Œå…¶ä¸­ `dpy0, dpy1` è™½ç„¶éƒ½åˆå§‹åŒ–ä¸º `out Bits(8 bits)`ï¼Œä½† Scala ä¼šå°†è¿™ç§å˜é‡å®šä¹‰è¯­å¥è§£é‡Šä¸ºæ‰§è¡Œåˆå§‹åŒ–è¯­å¥ä¸¤æ¬¡ï¼Œå› æ­¤å®ƒä»¬æ˜¯ä¸åŒçš„ä¿¡å·ã€‚

æœ€åçš„ `setName("")` ç•¥å¾®æœ‰ç‚¹é»‘é­”æ³•ï¼Œæ˜¯ä¸ºäº†ä¸æœ€åçš„æ¥å£çº¦æŸç¬¦åˆã€‚é»˜è®¤æƒ…å†µä¸‹ï¼ŒSpinalHDL ä¼šæŒ‰ç…§å˜é‡å±‚æ¬¡ä¸ºä¿¡å·å‘½åï¼Œä¾‹å¦‚å¦‚æœæ²¡æœ‰è¿™ä¸€è¡Œè¯­å¥ï¼Œ`leds` ä¿¡å·æœ€ç»ˆçš„åå­—ä¼šå˜ä¸º `gpio_leds`ï¼Œä½†è¿™æ ·å°±å’Œçº¦æŸä¸åŒ¹é…äº†ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ‰‹åŠ¨å–æ¶ˆè¿™ä¸ªå‰ç¼€ã€‚

#### ä¸»ä»æ¥å£

**Ports.scala**

```scala
case class CpldUartPorts() extends Bundle with IMasterSlave {
    val rdn, wrn, dataready, tbre, tsre = Bool()

    override def asMaster(): Unit = {
        in (dataready, tbre, tsre)
        out (rdn, wrn, dataready)
    }
}
```

è¿™æ˜¯ CPLD ä¸²å£ç›¸å…³ä¿¡å·ã€‚è¿™é‡Œæˆ‘ä»¬é™¤äº†ç»§æ‰¿ `Bundle` ç±»ä»¥å¤–ï¼Œè¿˜å®ç°äº† `IMasterSlave` ç‰¹è´¨ã€‚è¿™ä¸€ç‰¹è´¨æºäºä¸€ä¸ªéå¸¸å¸¸è§çš„éœ€æ±‚ï¼šå¾ˆå¤šæ—¶å€™åŒä¸€ç»„ä¿¡å·å¯èƒ½è¦åœ¨å¤šå¤„ä½¿ç”¨ï¼ŒåŒºåˆ«åªæ˜¯è¾“å…¥è¾“å‡ºç«¯å£ç›¸åï¼Œä¾‹å¦‚åŒä¸€ç»„ [Wishbone æ€»çº¿](https://lab.cs.tsinghua.edu.cn/cod-lab-docs/labs/lab4/wishbone/) ä¿¡å·éœ€è¦åœ¨ CPU å’Œ SRAM æ§åˆ¶å™¨ä¹‹é—´è¿æ¥ï¼Œå¯¹å®ƒä»¬æ¥è¯´åŒä¸€ä¿¡å·çš„æ–¹å‘å°±æ˜¯ç›¸åçš„ã€‚

> å‰é¢çš„ I å¯èƒ½æ˜¯æŒ‡ Interfaceã€‚æœ‰çš„è¯­è¨€æœ‰æ¥å£åç§°ä»¥ I å¼€å¤´çš„ä¹ æƒ¯ï¼Œä¾‹å¦‚ C#ï¼Œå°½ç®¡ Scala æ²¡æœ‰ã€‚

`IMasterSlave` ç‰¹è´¨æä¾›äº†å¯¹è¿™ç§è¡Œä¸ºçš„æŠ½è±¡ã€‚åªéœ€è¦å®ç° `asMaster` æ–¹æ³•ï¼Œåœ¨å…¶ä¸­å£°æ˜å½“è¿™ä¸€ç»„ä¿¡å·ä½œä¸ºä¸»ç«¯å£ä¾§æ—¶å…¶ä¸­ä¿¡å·çš„è¾“å…¥è¾“å‡ºæ–¹å‘ï¼Œå°±å¯ä»¥åœ¨å£°æ˜è¿™ç»„ä¿¡å·æ—¶é€šè¿‡ `master` å’Œ `slave` å‡½æ•°è·å¾—å¯¹åº”æ–¹å‘çš„ä¿¡å·ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬å¸Œæœ›å½“è¿™äº›ä¿¡å·ä½œä¸ºä¸»ä¾§ (CPU ä¾§) å£°æ˜æ—¶ï¼Œå…¶ä¸­çš„ `rdn, wrn, dataready` å¯¹ CPU æ¥è¯´æ˜¯è¾“å‡ºä¿¡å·ï¼Œå…¶ä½™ä¿¡å·æ˜¯è¾“å…¥ä¿¡å·ã€‚

è¿™é‡Œï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨ `setName`ï¼Œå› ä¸ºçº¦æŸä¸­å®šä¹‰çš„ä¿¡å·åå­—æ°å¥½å°±æ˜¯ `cpld_*`ã€‚

#### ä¸‰æ€æ¥å£

**Ports.scala**

```scala
case class SramPorts() extends Bundle with IMasterSlave {
    val data = TriState(Bits(32 bits))
    val addr = UInt(20 bits)
    val be_n = Bits(4 bits)
    val ce_n, oe_n, we_n = Bool()

    override def asMaster(): Unit = {
        out (addr, be_n, ce_n, oe_n, we_n)
        master (data)
    }
}
```

è¿™æ˜¯ SRAM ç›¸å…³ä¿¡å·ã€‚æˆ‘ä»¬åˆé‡åˆ°äº†ä¸€ä¸ªæ–°æ¦‚å¿µï¼šä¸‰æ€æ¥å£ `TriState`ã€‚å¯ä»¥å‚è€ƒ [ä¸‰æ€é—¨](https://lab.cs.tsinghua.edu.cn/cod-lab-docs/labs/lab4/tri_state/) ä¸­çš„ä»‹ç»ã€‚SRAM çš„æ¥å£ä¸­ï¼Œ`sram_data` æ˜¯ä¸€ä¸ªä¸‰æ€é—¨ï¼Œè¾“å…¥è¾“å‡ºå…±ç”¨ä¸€æ¡æ•°æ®çº¿ã€‚ä¸ºäº†é¿å…ä¸¤ç«¯è®¾å¤‡åŒæ—¶è¾“å‡ºï¼Œè®¾å¤‡åœ¨ä¸è¾“å‡ºä¿¡å·æ—¶åº”å½“æŠŠä¸‰æ€é—¨è®¾ç½®ä¸ºé«˜é˜»æ€ (Z)ã€‚åœ¨ Verilog/SV ä¸­ï¼Œé€šå¸¸é€šè¿‡æŠŠä¸‰æ€é—¨ `signal_io` æ‹†åˆ†ä¸º `singal_i`ã€`signal_o`ã€`signal_t` ä¸‰ä¸ªä¿¡å·ï¼Œåˆ†åˆ«è¡¨ç¤ºè¾“å…¥ä¿¡å·ã€è¾“å‡ºä¿¡å·ä»¥åŠæ˜¯å¦é«˜é˜»æ€ã€‚

SpinalHDL å¯¹è¿™ç§éœ€æ±‚è¿›è¡Œäº†å°è£…ï¼Œé€šè¿‡ `TriState` åŒ…è£…å™¨å°±å¯ä»¥å°†ä¸€ä¸ªä¿¡å·å£°æ˜ä¸ºä¸‰æ€ä¿¡å·ã€‚åŒæ—¶ï¼Œå®ƒä¹Ÿå®ç°äº† `IMasterSlave`ï¼Œå¯ä»¥åŒºåˆ†è¿æ¥ä¸¤ç«¯çš„ä¸åŒæ–¹å‘ã€‚

è¿™é‡Œï¼Œæˆ‘ä»¬åœ¨ `asMaster` ä¸­å°† `data` å£°æ˜ä¸ºä¸»ä¾§ï¼Œä»¥ä½¿ä¿¡å·æ–¹å‘ä¿æŒä¸€è‡´ã€‚`TriState` çš„å…·ä½“ç”¨æ³•å°†ä¼šåœ¨ä¹‹åä½¿ç”¨æ—¶è¯¦è¿°ã€‚

---

åé¢å°±æ²¡æœ‰æ–°å†…å®¹äº†ï¼Œç›´æ¥ä¾æ¬¡æŠŠ ThinPad ä¸­çš„ä¿¡å·æ¬è¿‡æ¥å°±è¡Œï¼š

**Ports.scala**

```scala
case class UartPorts() extends Bundle with IMasterSlave {
    val txd = Bool()
    val rxd = Bool()
    setName("")

    override def asMaster(): Unit = {
        in (rxd)
        out (txd)
    }
}

case class FlashPorts() extends Bundle with IMasterSlave {
    val a = UInt(23 bits)
    val d = TriState(Bits(16 bits))
    val rp_n, vpen, ce_n, oe_n, we_n, byte_n = Bool()

    override def asMaster(): Unit = {
        out (a, rp_n, vpen, ce_n, oe_n, we_n, byte_n)
        master (d)
    }
}

case class Sl811UsbPorts() extends Bundle with IMasterSlave {
    val a0, wr_n, rd_n, cs_n, rst_n, dack_n, intrq, drq_n = Bool()

    override def asMaster(): Unit = {
        in (intrq, drq_n)
        out (a0, wr_n, rd_n, cs_n, rst_n, dack_n)
    }
}

case class Dm9kEthPorts() extends Bundle with IMasterSlave {
    val cmd = Bool()
    val sd = TriState(Bits(16 bits))
    val iow_n, ior_n, cs_n, pwrst_n, int = Bool()

    override def asMaster(): Unit = {
        in (int)
        out (cmd, iow_n, ior_n, cs_n, pwrst_n)
        master (sd)
    }
}

case class VgaPorts() extends Bundle with IMasterSlave {
    val red, green = Bits(3 bits)
    val blue = Bits(2 bits)
    val hsync, vsync, clk, de = Bool()

    override def asMaster(): Unit = {
        out (red, green, blue, hsync, vsync, clk, de)
    }
}
```

### é¡¶å±‚æ¨¡å—æ¨¡æ¿

æœ‰äº†ä¸å¤–éƒ¨çš„ IO æ¥å£å®šä¹‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥å£°æ˜é¡¹ç›®çš„é¡¶å±‚æ¨¡å—äº†ã€‚é¡¶å±‚æ¨¡å—éœ€è¦å®Œæˆè¿™äº›ä»»åŠ¡ï¼š

- å°†å†…éƒ¨çš„å„å­æ¨¡å—æ•´åˆåˆ°ä¸€èµ·ã€‚
- å°†å¤–éƒ¨ IO ä¿¡å·ä¸å†…éƒ¨ä¿¡å·ç›¸è¿ã€‚
- å®šä¹‰ä¸€ä¸ªç»Ÿä¸€çš„æ—¶é’ŸåŸŸé©±åŠ¨æ‰€æœ‰å­æ¨¡å—ã€‚

æ•´åˆå†…éƒ¨å­æ¨¡å—éšç€å…·ä½“éœ€è¦å®Œæˆçš„ç¡¬ä»¶è®¾è®¡ä¸åŒè€Œä¸åŒï¼Œä½†è¿æ¥å¤–éƒ¨ä¿¡å·ä¸å®šä¹‰æ—¶é’ŸåŸŸå¯¹äºåœ¨ ThinPad ä¸Šçš„è®¾è®¡æ¥è¯´éƒ½æ˜¯é€šç”¨çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ª ThinPad çš„é€šç”¨é¡¶å±‚æ¨¡å—ï¼Œä¹‹ååœ¨å…·ä½“ä»»åŠ¡åˆ©ç”¨ SpinalHDL çš„é¢å‘å¯¹è±¡ç‰¹æ€§ç›´æ¥ç»§æ‰¿é€šç”¨é¡¶å±‚æ¨¡å—å³å¯åˆ›å»ºæ–°çš„é¡¶å±‚æ¨¡å—ï¼Œæ›´åŠ ç®€æ´ã€‚

**ThinpadTop.scala**

```scala
case class ThinPadTop(
    io_config: ThinPadIoConfig = ThinPadIoConfig(),
    simulation: Boolean = false,
) extends Component {
    val io = ThinPadPorts(io_config)
    noIoPrefix()

    ClockDomain.current.renamePulledWires(
        clock = "clk_50M",
        reset = "reset_btn",
    )
}
```

é¦–å…ˆæˆ‘ä»¬å£°æ˜äº† `io_config` å’Œ `simulation` ä¸¤ä¸ªå±æ€§ã€‚åœ¨åç»­é’ˆå¯¹ä¸åŒå®éªŒå®šä¹‰é¡¶å±‚æ¨¡å—æ—¶ï¼Œå¯ä»¥ä¼ å…¥ä¸åŒçš„ `io_config` å±æ€§è·å¾—ä¸åŒçš„ IO æ¥å£ï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨ `simulation` å±æ€§è¿›è¡Œæ¡ä»¶ç¼–è¯‘ï¼Œé’ˆå¯¹ä»¿çœŸå’Œç»¼åˆç”Ÿæˆä¸ä¸€æ ·çš„æ¨¡å—ã€‚

æ¥ä¸‹æ¥åŒæ ·åœ°ï¼Œæˆ‘ä»¬åˆ©ç”¨ `noIoPrefix` å–æ¶ˆ IO å‰ç¼€ï¼Œä»¥ä¾¿ä¸çº¦æŸæ–‡ä»¶ä¸­çš„ä¿¡å·åç›¸åŒ¹é…ã€‚

ä¸‹é¢ï¼Œæˆ‘ä»¬å°†å®šä¹‰å…¨å±€çš„æ—¶é’ŸåŸŸã€‚

#### æ—¶é’Ÿå’Œå¤ä½ä¿¡å·å£°æ˜

ä¼ ç»Ÿçš„ç¡¬ä»¶æè¿°è¯­è¨€ï¼Œä¾‹å¦‚ VHDL å’Œ Verilog æ˜¯ä¸ºäº†æè¿°æ¨¡æ‹Ÿç”µè·¯è€Œç”Ÿçš„ï¼Œå› æ­¤å¾ˆå¤šè¯­æ³•å¯¹äºæ•°å­—é€»è¾‘ç”µè·¯æ¥è¯´ä¸å¤ªè‡ªç„¶ã€‚ä¾‹å¦‚ï¼ŒVerilog ä¸­çš„ `always` å—éœ€è¦åœ¨æ•æ„Ÿä¿¡å·åˆ—è¡¨ä¸­åˆ—å‡ºæ‰€æœ‰æ•æ„Ÿä¿¡å·ï¼Œè€Œå¯¹äºæ—¶åºé€»è¾‘æ¥è¯´ï¼Œå°±æ˜¯æ—¶é’Ÿä¿¡å·å’Œå¤ä½ä¿¡å·ã€‚SystemVerilog ä¸­åˆ†åŒ–å‡ºäº† `always_ff` å—ä¸“é—¨è¡¨è¾¾æ—¶åºé€»è¾‘å—ï¼Œä½†ä»ç„¶éœ€è¦å£°æ˜æ—¶é’Ÿå’Œå¤ä½ä¿¡å·ã€‚

SpinalHDL ä¸“ä¸ºæè¿°æ•°å­—é€»è¾‘ç”µè·¯è€Œè®¾è®¡ï¼Œå› æ­¤æ¯ä¸ªæ¨¡å—éƒ½ä¼šè¿æ¥åˆ°ä¸€ä¸ªæ—¶é’ŸåŸŸä¸­ï¼Œä»æ—¶é’ŸåŸŸä¸­è·å–æ—¶é’Ÿå’Œå¤ä½ä¿¡å·ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±ä¸åŒåœ¨æ¯ä¸ªæ¨¡å—ä¸­é‡å¤å£°æ˜è¿™äº›ä¿¡å·äº†ã€‚åŒæ—¶ï¼ŒSpinalHDL ä¹Ÿä¸éœ€è¦åŒºåˆ†ç»„åˆé€»è¾‘å—å’Œæ—¶åºé€»è¾‘å—ï¼Œè€Œæ˜¯é€šè¿‡ä¿¡å·è‡ªèº«æ˜¯å¦ä¸ºå¯„å­˜å™¨ç±»å‹æ¥åˆ†åˆ«ç”Ÿæˆç»„åˆé€»è¾‘ä¸æ—¶åºé€»è¾‘ã€‚

SpinalHDL é€šè¿‡ `ClockDomain` ç±»å’Œå¯¹è±¡æä¾›äº†æ“ä½œæ—¶é’ŸåŸŸçš„ä¸€äº›æ–¹æ³•ã€‚ç”±äºæˆ‘ä»¬åœ¨ç»„æˆåŸç†èŒƒå›´å†…çš„è®¾è®¡ä¸€èˆ¬ä¸æ¶‰åŠåˆ°è·¨æ—¶é’ŸåŸŸï¼Œæˆ‘ä»¬å°†ä¼šç®€å•ä»‹ç»å°†è¦ç”¨åˆ°çš„ä¸€äº›ç”¨æ³•ã€‚

`ClockDomain.current` å±æ€§å¯ä»¥è·å–å½“å‰æ—¶é’ŸåŸŸã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæ—¶é’Ÿä¿¡å·çš„åå­—ä¸º `clk`ï¼Œå¤ä½ä¿¡å·çš„åå­—ä¸º `reset`ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ `clk_50M` ä½œä¸º CPU çš„ä¸»æ—¶é’Ÿï¼Œ`reset_btn` ä½œä¸ºå¤ä½ä¿¡å·ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é€šè¿‡ `renamePulledWires` æ–¹æ³•å®šä¹‰ä½œä¸ºæ—¶é’Ÿå’Œå¤ä½ä¿¡å·çš„ä¿¡å·åã€‚å‰é¢å®šä¹‰å¤–éƒ¨ IO æ¥å£æ—¶ï¼Œæˆ‘ä»¬å¿½ç•¥äº†è¿™ä¸¤ä¸ªä¿¡å·ï¼Œæ˜¯å› ä¸º SpinalHDL å°†ä¼šè‡ªåŠ¨ç”Ÿæˆæ—¶é’Ÿå’Œå¤ä½ä¿¡å·ï¼Œä¸éœ€è¦æ‰‹åŠ¨å®šä¹‰ã€‚

#### IP ä½¿ç”¨

IP (Intellectual Properties) æ˜¯é¢„å…ˆè®¾è®¡å¥½çš„ç¡¬ä»¶æ¨¡å—ï¼Œç±»ä¼¼äºè½¯ä»¶ç¼–ç¨‹ä¸­çš„ç¬¬ä¸‰æ–¹åº“ã€‚åœ¨ Vivado ç­‰å·¥å…·ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è®¾å®šå‚æ•°å¹¶æ·»åŠ  IP æ¥ç›´æ¥ä½¿ç”¨å®ƒä»¬çš„åŠŸèƒ½ã€‚

é»˜è®¤çš„è¾“å…¥ä¿¡å·åªèƒ½æä¾› 50 MHz çš„æ—¶é’Ÿé¢‘ç‡ï¼Œè€Œæˆ‘ä»¬å¯èƒ½éœ€è¦é€šè¿‡ PLL (Phase-Locked Loop, é”ç›¸ç¯) IP æ¥ç”Ÿæˆå®é™…éœ€è¦é¢‘ç‡çš„æ—¶é’Ÿã€‚ä¸å‰é¢ä»‹ç»çš„å¤–éƒ¨æ¨¡å—å£°æ˜ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å£°æ˜ SpinalHDL é»‘ç›’æ¨¡å—æ¥ä½¿ç”¨ IP æ¨¡å—ã€‚ä¸åŒçš„æ˜¯ï¼Œç”±äºä¸å­˜åœ¨å®é™…çš„å®ç°ï¼Œæˆ‘ä»¬åªéœ€è¦é€šè¿‡ `setBlackBoxName` æŒ‡å®š IP æ¨¡å—çš„åå­—å³å¯ã€‚

**Pll.scala**

```scala
class Pll extends BlackBox {
    val io = new Bundle {
        val clk_in1, reset = in Bool()
        val clk_out1, clk_out2, locked = out Bool()
    }
    noIoPrefix()
    setBlackBoxName("pll_example")
    spinalSimWhiteBox()

    io.clk_out2.allowPruning()

    io.clk_out1 := io.clk_in1
    io.clk_out2 := io.clk_in1
    io.locked := !io.reset
}
```

SpinalHDL åœ¨ç¼–è¯‘æ—¶ä¼šæ£€æŸ¥æ˜¯å¦æœ‰ä¿¡å·æœªè¢«ä½¿ç”¨ï¼Œå¹¶è¿›è¡Œè­¦å‘Šã€‚è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨çš„ PLL IP æœ‰ä¸¤ä¸ªè¾“å‡ºæ—¶é’Ÿä¿¡å·ï¼Œç”±äº `clk_out2` ä¸ä½¿ç”¨ï¼Œæˆ‘ä»¬é€šè¿‡ `allowPruning()` æ–¹æ³•æŠ‘åˆ¶è­¦å‘Šã€‚

ç”±äºè¿™æ˜¯ä¸€ä¸ª IPï¼Œå¹¶ä¸åƒæœ‰ Verilog æºç çš„å¤–éƒ¨æ¨¡å—é‚£æ ·å¯ä»¥åœ¨ä»¿çœŸæ—¶ç›´æ¥ä½¿ç”¨ï¼Œæˆ‘ä»¬ä½¿ç”¨ `spinalSimWhiteBox()` å£°æ˜åœ¨ä»¿çœŸæ—¶è¿™å¹¶ä¸æ˜¯ä¸€ä¸ªé»‘ç›’æ¨¡å—ï¼Œå¹¶é€šè¿‡å°†è¾“å‡ºä¿¡å·ç›´æ¥ç½®ä¸ºè¾“å…¥ä¿¡å·çš„æ–¹å¼æ¨¡æ‹Ÿ PLLã€‚åŒæ—¶ï¼Œæˆ‘ä»¬å°†é”å®šä¿¡å· `locked` ç›´æ¥ç½®ä¸ºå¤ä½ä¿¡å·çš„éã€‚

#### åŒºåŸŸ

åœ¨ Verilog ä¸­ï¼Œä¸€ä¸ªæ¨¡å—ä¸­çš„æ‰€æœ‰ä¿¡å·å…±äº«ä¸€ä¸ªå‘½åç©ºé—´ï¼Œé€šå¸¸é‡‡ç”¨å‰ç¼€çš„æ–¹å¼ç»„ç»‡é€»è¾‘ç›¸å…³çš„ä¿¡å·ã€‚ç„¶è€Œï¼Œè¿™æ ·å¹¶ä¸åˆ©äºæ˜ç¡®åŒºåˆ†ä»£ç ï¼Œä½†å¦‚æœä¸ºç›¸å…³çš„é€»è¾‘å®šä¹‰ä¸€ä¸ªæ–°æ¨¡å—åˆç•¥æ˜¾ç¹çã€‚SpinalHDL æä¾›äº†åŒºåŸŸ (`Area`) æ¥ç»„ç»‡ä¸€ä¸ªæ¨¡å—ä¸­çš„ä»£ç ä½œç”¨åŸŸã€‚

```scala
val tickCounter = new Area {
    val value = Reg(UInt(3 bits))
    val reset = False
    when(timer.tick) {          // Refer to the tick from timer area
        value := value + 1
    }
    when(reset) {
        value := 0
    }
}
```

åœ¨ä¸Šé¢è¿™æ®µç¤ºä¾‹ä»£ç ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªåä¸º `tickCounter` çš„åŒºåŸŸï¼Œåœ¨å…¶ä¸­å£°æ˜äº†ä¸€äº›ä¿¡å·ä»¥åŠè¿™äº›ä¿¡å·çš„ç›¸å…³é€»è¾‘ã€‚è¿™æ ·ï¼Œåœ¨ä¹‹åçš„ä»£ç ä¸­å¯ä»¥ä½¿ç”¨å½¢å¦‚ `tickCounter.value` çš„æ–¹å¼è®¿é—®å…¶ä¸­çš„ä¿¡å·ï¼Œä½¿å¾—é€»è¾‘åˆ’åˆ†æ›´åŠ æ˜ç¡®ã€‚

#### PLL æ—¶é’ŸåŸŸ

ä¸‹é¢ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ PLL å£°æ˜ä¸€ä¸ªæ–°çš„æ—¶é’ŸåŸŸï¼Œä½œä¸ºç³»ç»Ÿå®é™…ä½¿ç”¨çš„æ—¶é’ŸåŸŸã€‚

**ThinpadTop.scala**

```scala
package cod

import spinal.core._
import spinal.lib._

case class ThinPadTop(
    io_config: ThinPadIoConfig = ThinPadIoConfig(),
    simulation: Boolean = false,
) extends Component {
    val io = ThinPadPorts(io_config)
    noIoPrefix()

    ClockDomain.current.renamePulledWires(
        clock = "clk_50M",
        reset = "reset_btn",
    )

    val clkCtrl = new Area {
        // PLL blackbox
        val pll = new Pll
        pll.io.clk_in1 := ClockDomain.current.readClockWire
        pll.io.reset := ClockDomain.current.readResetWire

        // Clock domains
        val sysClkDomain = ClockDomain.internal(
            name = "sys",
            frequency = FixedFrequency(17.5 MHz),
        )
        sysClkDomain.clock := pll.io.clk_out1
        sysClkDomain.reset := ResetCtrl.asyncAssertSyncDeassert(
            input = pll.io.locked,
            clockDomain = sysClkDomain,
            inputPolarity = LOW,
            outputPolarity = HIGH,
        )
    }

    ClockDomain.push(clkCtrl.sysClkDomain)
}
```

è¿™é‡Œï¼Œæˆ‘ä»¬é¦–å…ˆä¾‹åŒ–äº† PLL IP æ¨¡å—ï¼Œå°†é»˜è®¤æ—¶é’Ÿä¿¡å· (å³ 50 MHz æ—¶é’Ÿ) è¿æ¥åˆ° PLL çš„è¾“å…¥ç«¯å£ï¼Œé»˜è®¤å¤ä½ä¿¡å·è¿æ¥åˆ° PLL çš„å¤ä½ç«¯å£ã€‚ä¹‹åæˆ‘ä»¬ä½¿ç”¨ `ClockDomain.internal` å‡½æ•°ç”Ÿæˆä¸€ä¸ªæ–°çš„å†…éƒ¨æ—¶é’ŸåŸŸï¼Œè¿™é‡Œ `frequency` å‚æ•°å¹¶ä¸ä¼šå®é™…å½±å“åˆ°ç»¼åˆå‡ºçš„æ—¶é’Ÿé¢‘ç‡ï¼Œåªæ˜¯ä¸ºäº†æ–¹ä¾¿åç»­å…¶ä»–æ¨¡å—è®¿é—®æ—¶é’Ÿé¢‘ç‡ã€‚çœŸæ­£çš„é¢‘ç‡è®¾å®šåœ¨ Vivado çš„ IP è®¾ç½®ä¸­å®Œæˆã€‚

ç„¶åï¼Œæˆ‘ä»¬è®¾å®šæ–°çš„æ—¶é’ŸåŸŸçš„æ—¶é’Ÿå’Œå¤ä½ä¿¡å·ã€‚æ—¶é’Ÿä¿¡å·ç›´æ¥è®¾å®šä¸º PLL çš„è¾“å‡ºå³å¯ã€‚å¤ä½ä¿¡å·é€šè¿‡ `ResetCtrl` å·¥å…·ç±»ä¸­çš„ `asyncAssertSyncDeassert` æ–¹æ³•ç”Ÿæˆï¼Œæ•ˆæœæ˜¯å°† PLL çš„å¼‚æ­¥é”å®šä¿¡å·è¿‡æ»¤ä¸ºåŒæ­¥çš„å¤ä½ä¿¡å·ã€‚åŒæ—¶æˆ‘ä»¬é€šè¿‡ `inputPolarity` ä¸ `outputPolarity` è®¾å®šäº†ä¿¡å·çš„ææ€§ï¼Œä¹Ÿå°±æ˜¯å½“å¤ä½æŒ‰é’®è§¦å‘æ—¶ï¼ŒPLL é‡æ–°å°è¯•é”å®šï¼Œé”å®šä¿¡å·å˜ä½æ—¶ï¼Œæ­¤æ—¶å¤ä½ä¿¡å·åº”å˜ä¸ºé«˜ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡ `ClockingArea` æ¥åœ¨ä¸€ä¸ªåŒºåŸŸå†…ä½¿ç”¨ä¸€ä¸ªæ—¶é’ŸåŸŸï¼Œä¸è¿‡è¿™é‡Œæˆ‘ä»¬å¸Œæœ›åœ¨å…¨å±€éƒ½ä½¿ç”¨è¿™ä¸€æ—¶é’ŸåŸŸï¼Œæ‰€ä»¥é€šè¿‡ `ClockDomain.push` å°†æ–°æ—¶é’ŸåŸŸåŠ å…¥æ—¶é’ŸåŸŸæ ˆå³å¯ï¼Œä¹‹åçš„ä»£ç éƒ½å°†ä½¿ç”¨è¿™ä¸€åˆ†é¢‘è¿‡åçš„æ—¶é’ŸåŸŸã€‚

### çœŸæ­£çš„é¡¶å±‚æ¨¡å—

è¿™é‡Œæˆ‘ä»¬é€šè¿‡ç»§æ‰¿å‰é¢å®šä¹‰çš„é¡¶å±‚æ¨¡å—æ¨¡æ¿æ¥å®šä¹‰ç”¨äºå®éªŒ 2 çš„é¡¶å±‚æ¨¡å—ã€‚

**lab2/Top.scala**

```scala
package cod.lab2

class Lab2Top extends ThinPadTop(ThinPadIoConfig(
    enableBaseRam = false,
    enableExtRam = false,
    enableUart = false,
)) {
    val counter = new Counter
    val trigger = new Trigger
    val seg_7 = new Seg7

    trigger.io.push_btn := io.push_btn
    counter.io.trigger := trigger.io.trigger
    seg_7.io.iDIG := counter.io.count
    io.gpio.dpy0 := seg_7.io.oSEG1

    io.gpio.dpy1 := 0
    io.gpio.leds := 0
}
```

è¿™é‡Œæˆ‘ä»¬é€šè¿‡é…ç½®ç±»å…³é—­äº†ä¸éœ€è¦çš„å¤–éƒ¨ IO æ¥å£ï¼Œç„¶åå£°æ˜äº†å®é™…çš„é¡¶å±‚æ¨¡å—é€»è¾‘ã€‚æˆ‘ä»¬é¦–å…ˆä¾‹åŒ–äº†å„ä¸ªå­æ¨¡å—ï¼Œç„¶åè¿›è¡Œå­æ¨¡å—ä¹‹é—´çš„è¿çº¿ã€‚ä¸åŒäº SystemVerilogï¼Œæˆ‘ä»¬å¯ä»¥ååˆ†æ–¹ä¾¿åœ°å°†ä¸¤ä¸ªæ¨¡å—çš„è¾“å…¥è¾“å‡ºä¿¡å·ç›¸è¿ï¼Œæ— éœ€é€šè¿‡ä¸­é—´ä¿¡å·ä¸­è½¬ã€‚

ç”±äº `dpy1` å’Œ `leds` ä¿¡å·æœªä½¿ç”¨ï¼Œæˆ‘ä»¬å°†å…¶èµ‹å€¼ä¸ºé›¶æ¥é¿å…è­¦å‘Šã€‚SpinalHDL ä¼šæ£€æŸ¥æœªä½¿ç”¨çš„æ¨¡å—ï¼Œè¿™ä½¿å¾—å†™é”™ä¿¡å·åå¯¼è‡´æ¥çº¿é”™è¯¯ç­‰æ¼æ´æ›´ä¸å®¹æ˜“å‘ç”Ÿã€‚

### ä»£ç ç”Ÿæˆ

ç»ˆäºï¼Œæˆ‘ä»¬å†™å®Œäº† SpinalHDL éƒ¨åˆ†çš„ä»£ç ğŸ‰ï¼ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•æŠŠ SpinalHDL ä»£ç è½¬æ¢ä¸º SystemVerilog ä»£ç å‘¢ï¼Ÿ

æ­£å¦‚å‰é¢æåˆ°è¿‡çš„ï¼ŒSpinalHDL æœ¬è´¨ä¸Šåªæ˜¯ä¸€ä¸ª Scala åº“ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨ç¨‹åºçš„ä¸»å‡½æ•°ä¸­è°ƒç”¨ SpinalHDL æä¾›çš„å‡½æ•°ï¼Œå°†é¡¶å±‚æ¨¡å—çš„å®ä¾‹ç”Ÿæˆä¸º SystemVerilog ä»£ç ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ `SpinalConfig` ç±»é…ç½®ç”Ÿæˆçš„è¡Œä¸ºï¼Œä¸ºäº†æ›´åŠ æ–¹ä¾¿åœ°å¤ç”¨é…ç½®ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰å•ä¾‹ç±»æ¥ç®€åŒ–æ¯æ¬¡ç”Ÿæˆçš„é…ç½®ï¼š

```scala
object Config {
  def spinal = SpinalConfig(
    mode = SystemVerilog,
    targetDirectory = "thinpad_top.srcs/sources_1/spinal",
  )

  def sim = SimConfig.withConfig(spinal).withVcdWave
}
```

è¿™é‡Œå•ä¾‹ç±» `Config` æœ‰ä¸¤ä¸ªå±æ€§ `spinal` ä¸ `sim`ï¼Œåˆ†åˆ«è¡¨ç¤ºåŸºç¡€é…ç½®ä¸ä»¿çœŸé…ç½®ã€‚åŸºç¡€é…ç½®ä¸º `SpinalConfig` çš„å®ä¾‹ï¼Œæ¨¡å¼æŒ‡å®šä¸º SystemVerilog (å½“ç„¶ä¹Ÿå¯ä»¥æ”¹ä¸ºå…¶ä»–è¯­è¨€)ï¼Œç›®æ ‡ç›®å½•æŒ‡å®šä¸ºå¸Œæœ›æ”¾ç½®ç”Ÿæˆçš„ SystemVerilog ä»£ç çš„ç›®å½•ã€‚ä»¿çœŸæ¨¡å—ä¸º `SimConfig` çš„å®ä¾‹ï¼Œå®ƒåŸºäºå‰é¢çš„åŸºç¡€é…ç½®ï¼Œä½†æˆ‘ä»¬è®©å…¶ç”Ÿæˆ VCD æ³¢å½¢ä»¥ä¾¿è°ƒè¯•ã€‚

æœ€åçš„æœ€åï¼Œæˆ‘ä»¬å®šä¹‰ç¨‹åºä¸»å‡½æ•°ï¼Œç”Ÿæˆ SystemVerilog ä»£ç ï¼š

**lab2/Top.scala**

```scala
object GenerateLab2 extends App {
    Config.spinal.generate(InOutWrapper(new Lab2Top)).printPruned()
}
```

è¿™é‡Œçš„ `Config` å³ä¸ºæˆ‘ä»¬å‰é¢å®šä¹‰çš„é…ç½®ã€‚æˆ‘ä»¬è°ƒç”¨ `generate` å‡½æ•°å³å¯ç”ŸæˆæŒ‡å®šæ¨¡å—çš„ SystemVerilog ä»£ç ï¼ŒåŒæ—¶æˆ‘ä»¬è°ƒç”¨ `printPruned` å‡½æ•°æ¥æ˜¾ç¤ºæœªä½¿ç”¨çš„ä¿¡å·ï¼Œä»¥ä¾¿æ£€æŸ¥æ˜¯å¦æœ‰æ¥çº¿é”™è¯¯ã€‚

è¿™é‡Œæˆ‘ä»¬æ²¡æœ‰ç›´æ¥ä½¿ç”¨ `new Lab2Top` ä½œä¸ºè¦ç”Ÿæˆçš„æ¨¡å—ï¼Œè€Œæ˜¯å°†å…¶åŒ…è£…åœ¨ `InOutWrapper` ä¸­ã€‚è¿™æ˜¯å› ä¸ºå‰é¢æˆ‘ä»¬ä½¿ç”¨äº† `TriState` ä½œä¸ºä¸‰æ€æ¥å£çš„å°è£…ï¼Œè€Œ `TriState` æ¥å£å®é™…ä¸Šæ˜¯ä¸‰æ¡ä¿¡å·çº¿çš„å°è£…ï¼Œåœ¨é¡¶å±‚æ¨¡å—æˆ‘ä»¬éœ€è¦å°†å…¶è½¬æ¢ä¸ºå•ä¸€çš„ `inout` ä¸‰æ€æ¥å£ï¼Œ`InOutWrapper` å¯ä»¥è‡ªåŠ¨å¸®æˆ‘ä»¬å®Œæˆè¿™ç§è½¬æ¢ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¿è¡Œç¨‹åºï¼š

```shell
mill cod.runMain cod.lab2.GenerateLab2
```

ä¹‹åï¼Œå°±å¯ä»¥åœ¨é…ç½®çš„ç”Ÿæˆç›®å½•ä¸‹æ‰¾åˆ°ç”Ÿæˆçš„ SystemVerilog ä»£ç ï¼š

**Lab2Top.sv**

```verilog
// Generator : SpinalHDL v1.9.4    git head : 270018552577f3bb8e5339ee2583c9c22d324215
// Component : Lab2Top
// Git hash  : 54fac1a01bf69ec0c7d8b775b635cdfe695df084

`timescale 1ns/1ps

module Lab2Top (
  input  wire          clk_11M0592,
  input  wire          push_btn,
  input  wire [3:0]    touch_btn,
  input  wire [31:0]   dip_sw,
  output wire [15:0]   leds,
  output wire [7:0]    dpy0,
  output wire [7:0]    dpy1,
  input  wire          clk_50M,
  input  wire          reset_btn
);

  wire                bufferCC_1_io_dataIn;
  wire                clkCtrl_pll_clk_out1;
  wire                clkCtrl_pll_clk_out2;
  wire                clkCtrl_pll_locked;
  wire                bufferCC_1_io_dataOut;
  wire       [3:0]    counter_1_io_count;
  wire                trigger_1_io_trigger;
  wire       [7:0]    seg_7_oSEG1;
  wire                sys_clk;
  wire                sys_reset;

  pll_example clkCtrl_pll (
    .clk_in1  (clk_50M             ), //i
    .reset    (reset_btn           ), //i
    .clk_out1 (clkCtrl_pll_clk_out1), //o
    .clk_out2 (clkCtrl_pll_clk_out2), //o
    .locked   (clkCtrl_pll_locked  )  //o
  );
  BufferCC bufferCC_1 (
    .io_dataIn  (bufferCC_1_io_dataIn ), //i
    .io_dataOut (bufferCC_1_io_dataOut), //o
    .sys_clk    (sys_clk              ), //i
    .locked     (clkCtrl_pll_locked   )  //i
  );
  Counter counter_1 (
    .io_trigger (trigger_1_io_trigger   ), //i
    .io_count   (counter_1_io_count[3:0]), //o
    .sys_clk    (sys_clk                ), //i
    .sys_reset  (sys_reset              )  //i
  );
  Trigger trigger_1 (
    .io_push_btn (push_btn            ), //i
    .io_trigger  (trigger_1_io_trigger), //o
    .sys_clk     (sys_clk             ), //i
    .sys_reset   (sys_reset           )  //i
  );
  SEG7_LUT seg_7 (
    .iDIG  (counter_1_io_count[3:0]), //i
    .oSEG1 (seg_7_oSEG1[7:0]       )  //o
  );
  assign sys_clk = clkCtrl_pll_clk_out1;
  assign bufferCC_1_io_dataIn = (1'b0 ^ 1'b0);
  assign sys_reset = bufferCC_1_io_dataOut;
  assign dpy0 = seg_7_oSEG1;
  assign dpy1 = 8'h00;
  assign leds = 16'h0000;

endmodule

module Trigger (
  input  wire          io_push_btn,
  output wire          io_trigger,
  input  wire          sys_clk,
  input  wire          sys_reset
);

  reg                 io_push_btn_regNext;

  assign io_trigger = (io_push_btn && (! io_push_btn_regNext));
  always @(posedge sys_clk or posedge sys_reset) begin
    if(sys_reset) begin
      io_push_btn_regNext <= 1'b0;
    end else begin
      io_push_btn_regNext <= io_push_btn;
    end
  end


endmodule

module Counter (
  input  wire          io_trigger,
  output wire [3:0]    io_count,
  input  wire          sys_clk,
  input  wire          sys_reset
);

  wire       [4:0]    _zz__zz_when_UInt_l120;
  wire       [1:0]    _zz__zz_when_UInt_l120_1;
  reg        [3:0]    counter_1;
  wire       [4:0]    _zz_when_UInt_l120;
  reg        [3:0]    _zz_counter;
  wire                when_UInt_l120;

  assign _zz__zz_when_UInt_l120_1 = {1'b0,1'b1};
  assign _zz__zz_when_UInt_l120 = {3'd0, _zz__zz_when_UInt_l120_1};
  assign _zz_when_UInt_l120 = ({1'b0,counter_1} + _zz__zz_when_UInt_l120);
  assign when_UInt_l120 = (|_zz_when_UInt_l120[4 : 4]);
  always @(*) begin
    if(when_UInt_l120) begin
      _zz_counter = 4'b1111;
    end else begin
      _zz_counter = _zz_when_UInt_l120[3 : 0];
    end
  end

  assign io_count = counter_1;
  always @(posedge sys_clk or posedge sys_reset) begin
    if(sys_reset) begin
      counter_1 <= 4'b0000;
    end else begin
      if(io_trigger) begin
        counter_1 <= _zz_counter;
      end
    end
  end


endmodule

module BufferCC (
  input  wire          io_dataIn,
  output wire          io_dataOut,
  input  wire          sys_clk,
  input  wire          locked
);

  (* async_reg = "true" *) reg                 buffers_0;
  (* async_reg = "true" *) reg                 buffers_1;

  assign io_dataOut = buffers_1;
  always @(posedge sys_clk or negedge locked) begin
    if(!locked) begin
      buffers_0 <= 1'b1;
      buffers_1 <= 1'b1;
    end else begin
      buffers_0 <= io_dataIn;
      buffers_1 <= buffers_0;
    end
  end


endmodule
```

è‡³æ­¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨ Vivado ä¸­æ·»åŠ ç”Ÿæˆçš„ SystemVerilog æ–‡ä»¶ï¼Œå°†å…¶è®¾ç½®ä¸ºé¡¶å±‚æ¨¡å—ï¼Œç„¶åè¿›è¡Œç»¼åˆã€å®ç°å’Œç”Ÿæˆæ¯”ç‰¹æµç­‰æ­¥éª¤äº†ã€‚

### ä»¿çœŸ

è™½ç„¶è¿™ä¸€å°å®éªŒè¿˜æ²¡æœ‰è¦æ±‚ä»¿çœŸï¼Œä½†æˆ‘ä»¬ä¸å¦¨ä»¥æ­¤ä½“éªŒä¸‹ SpinalHDL æ–¹ä¾¿å¿«é€Ÿçš„ä»¿çœŸåŠŸèƒ½ã€‚è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†åˆ©ç”¨ SpinalHDL ä¸ Verilator çš„äº’æ“ä½œç‰¹æ€§ï¼Œé€šè¿‡ä¹¦å†™ SpinalHDL ä»£ç æ¥è¿›è¡Œä»¿çœŸå¹¶ç›´æ¥ç”Ÿæˆå¯ä»¥ç”¨ç¬¬ä¸‰æ–¹å·¥å…·æŸ¥çœ‹çš„æ³¢å½¢ã€‚å’Œé¾Ÿé€Ÿçš„ Vivado ä»¿çœŸè¯´å†è§å§ï¼

ä¹‹å‰çš„ä¸»ç¨‹åºæ˜¯ä»£ç ç”Ÿæˆï¼Œè€Œä»¿çœŸçš„ä¸»ç¨‹åºè‡ªç„¶æ˜¯æ‰§è¡Œä¸€æ®µä»¿çœŸä»£ç ã€‚é€šè¿‡ `SimConfig` çš„ `doSim` å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ä¼ å…¥ä¸€ä¸ªé—­åŒ…å£°æ˜ä»¿çœŸæ‰§è¡Œçš„æ­¥éª¤ï¼Œä»è€Œæ–¹ä¾¿åœ°è¿›è¡Œä»¿çœŸã€‚è¯¥é—­åŒ…æ¥å—ä¸€ä¸ªå‚æ•°ï¼Œå³å¾…æµ‹è¯•çš„é¡¶å±‚æ¨¡å— (DUT, Device Under Test)ï¼š

**lab2/Top.scala**

```scala
object TestLab2 extends App {
    Config.sim.compile(InOutWrapper(new Lab2Top)).doSim { dut =>
        dut.io.push_btn #= false

        dut.clockDomain.forkStimulus(10 ns)
        dut.clockDomain.waitSampling()

        var count = 0

        for (_ <- 0 until 20) {
            sleep(100 ns)
            dut.io.push_btn #= true
            sleep(100 ns)
            dut.io.push_btn #= false

            if (count < 15) {
                count += 1
            }
            val real = dut.counter.counter.toInt
            assert(real == count, s"Got $real, expected $count")
        }
        sleep(200 ns)
    }
}
```

ä¹¦å†™æ¨¡å—ä»£ç æ—¶ï¼Œæˆ‘ä»¬çš„èµ‹å€¼æ˜¯å¯¹å†…éƒ¨ä¿¡å·èµ‹å€¼ã€‚ä»¿çœŸä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¯¹é¡¶å±‚æ¨¡å—çš„å¤–éƒ¨ IO ä¿¡å·èµ‹å€¼ï¼Œå¹¶ä¸”è¿™ä¸ªå€¼å¹¶ä¸ç”±å…¶ä»–ä¿¡å·æä¾›ï¼Œè€Œæ˜¯ç”±ä»¿çœŸæ‰§è¡Œæ—¶çš„å˜é‡è®¾å®šï¼Œå› æ­¤ SpinalHDL æä¾›äº† `#=` è¿ç®—ç¬¦æ¥ä¸“é—¨è¡¨ç¤ºä»¿çœŸæ—¶å¯¹ä¿¡å·çš„é©±åŠ¨ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬å°†æŒ‰é’®ç½®ä¸º `false`ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ `False`ï¼Œå› ä¸ºè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ’ä¸ºä½çš„ `Bool` ä¿¡å·ï¼Œè€Œä»¿çœŸé©±åŠ¨ä¿¡å·ä¸èƒ½ä½¿ç”¨ç¡¬ä»¶ä¸­çš„ä¿¡å·ï¼Œåªèƒ½ä½¿ç”¨ Scala åŸç”Ÿç±»å‹ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é€šè¿‡å¯¹ `dut.clockDomain` çš„è®¾å®šæ¥æ¨¡æ‹Ÿæ—¶é’Ÿã€‚`forkStimulus` å‡½æ•°èƒ½å¤Ÿæ¨¡æ‹ŸæŒ‡å®šå‘¨æœŸçš„æ—¶é’Ÿä¿¡å·ï¼ŒåŒæ—¶æˆ‘ä»¬é€šè¿‡ `waitSampling` å‡½æ•°æ¥ç­‰å¾…æ—¶é’Ÿçš„é¦–æ¬¡é‡‡æ ·ï¼Œä¹‹åå†æ‰§è¡Œåé¢çš„ä»£ç ã€‚

æ³¨æ„ä»¿çœŸçš„è¿è¡Œæ—¶å°±æ˜¯ä¸Šé¢æä¾›çš„é—­åŒ…ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Scala æä¾›çš„å„ç§åŠŸèƒ½ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬è®¾å®šå˜é‡ `count` æ¥è¡¨ç¤ºæœŸæœ›çš„è®¡æ•°å€¼ï¼Œç„¶åé€šè¿‡ä¸€ä¸ª `for` å¾ªç¯æ¨¡æ‹Ÿæ•°æ¬¡æŒ‰é”®å¹¶é‡Šæ”¾çš„æµç¨‹ã€‚æ¯æ¬¡æŒ‰é”®å‰æˆ‘ä»¬é€šè¿‡ `sleep` å‡½æ•°ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œç„¶åé©±åŠ¨æ”¹å˜æŒ‰é”®ä¿¡å·çš„å€¼ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ç»´æŠ¤ `count` å˜é‡çš„å€¼ï¼Œå†å°†å…¶ä¸ä»¿çœŸç¡¬ä»¶å®é™…çš„ä¿¡å·å€¼æ¯”è¾ƒã€‚

> `a to b` ä¼šç”Ÿæˆ $[a, b]$ åŒºé—´ï¼Œè€Œ `a until b` ä¼šç”Ÿæˆ $[a, b)$ åŒºé—´ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªä¿¡å·çš„ `to*` æ–¹æ³•åœ¨ä»¿çœŸæ—¶è¯»å–ç¡¬ä»¶ä¿¡å·çš„å€¼ï¼Œè½¬æ¢ä¸º Scala åŸç”Ÿç±»å‹ã€‚å¯¹äºæ¨¡å—çš„ IO ä¿¡å·ï¼Œå¯ä»¥ç›´æ¥åœ¨ä»¿çœŸæ—¶è®¿é—®ã€‚å¯¹äºå†…éƒ¨ä¿¡å·ï¼Œéœ€è¦é€šè¿‡ `simPublic` å£°æ˜å…¶ä»¿çœŸæ—¶å¯¹å¤–å¯è§ï¼š

**Counter.scala**

```scala
class Counter extends Component {
    // ...
    val counter = Reg(UInt(4 bits)) init(0) simPublic()
    // ...
}
```

è¿™ä¹‹åå°±å¯ä»¥æ ¹æ®å–å‡ºçš„å€¼è¿›è¡Œè¿›ä¸€æ­¥çš„æ“ä½œï¼Œä¾‹å¦‚å°†å®ƒä¸æœŸæœ›å€¼æ¯”è¾ƒï¼Œä¸ç¬¦åˆæ—¶é€€å‡ºã€‚è¿™é‡Œçš„ `assert` æ–¹æ³•å°±æ˜¯ Scala è‡ªèº«çš„æ–­è¨€æ–¹æ³•ï¼Œå¹¶æ²¡æœ‰ç‰¹åˆ«çš„é­”æ³•ã€‚

è¿™é‡Œï¼Œéœ€è¦å†æ¬¡å¼ºè°ƒä¸€ä¸‹ä»£ç ä¸­çš„é€»è¾‘åœ¨ä½•æ—¶æ‰§è¡Œã€‚å¯¹äºä»£ç ç”Ÿæˆéƒ¨åˆ†ï¼ŒScala ä»£ç çš„è¿è¡Œè¿‡ç¨‹æ˜¯ç”Ÿæˆ SystemVerilogï¼Œå› æ­¤åœ¨å…¶ä¸­çš„æ ‡å‡†ç±»å‹å˜é‡ (å¦‚ Scala å†…ç½®ç±»å‹  `Boolean`ã€`Int`ã€`Long` ç­‰)åªèƒ½ç”¨äºæ§åˆ¶ä»£ç ç”Ÿæˆï¼Œæ— æ³•å¯¹ç¡¬ä»¶é€»è¾‘äº§ç”Ÿå®é™…å½±å“ï¼Œè€Œä¿¡å·ç±»å‹ (ä¾‹å¦‚ `Bool`ã€`Bits`ã€`UInt`ã€`SInt`) ç­‰å°†ç”¨äºå®é™…æè¿°ç¡¬ä»¶é€»è¾‘ã€‚å¯¹äºä»¿çœŸéƒ¨åˆ†ï¼ŒScala ä»£ç çš„è¿è¡Œè¿‡ç¨‹æ˜¯æ ¹æ®è®¾å®šå¥½çš„æµç¨‹æ¨¡æ‹Ÿç¡¬ä»¶æ‰§è¡Œï¼Œå› æ­¤å…¶ä¸­çš„æ ‡å‡†ç±»å‹å˜é‡å°†ç”¨äºæ§åˆ¶ä»¿çœŸçš„æ‰§è¡Œæµï¼Œè€Œç¡¬ä»¶ä¿¡å·ç±»å‹é€šè¿‡ `#=` ä¸ `to*` æ¥è¿›è¡Œé©±åŠ¨å’Œè¯»å–ï¼Œä»¥è®¾å®šå’Œè·å¾—ä»¿çœŸç¡¬ä»¶çš„ä¿¡å·ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬è¿è¡Œä»£ç ï¼š

```bash
mill cod.runMain cod.lab2.TestLab2
```

æ­¤æ—¶å¯ä»¥çœ‹åˆ° SpinalHDL å°†ä¼šè°ƒç”¨ Verilator æ‰§è¡Œä»¿çœŸï¼š

```ini
[46/46] cod.runMain 
[Runtime] SpinalHDL v1.9.4    git head : 270018552577f3bb8e5339ee2583c9c22d324215
[Runtime] JVM max memory : 4096.0MiB
[Runtime] Current date : 2024.05.04 23:16:03
[Progress] at 0.000 : Elaborate components
[Progress] at 0.429 : Checks and transforms
[Progress] at 0.488 : Generate Verilog
[Done] at 0.548
[Progress] Simulation workspace in /Users/abmfy/Code/cod23-grp04/./simWorkspace/Lab2Top
[Progress] Verilator compilation started
[Progress] Verilator compilation done in 8799.761 ms
[Progress] Start Lab2Top test simulation with seed 1564470203
[Done] Simulation done in 35.282 ms
```

ç¬¬ä¸€æ¬¡ä»¿çœŸæ—¶ï¼Œç¼–è¯‘ Verilator éœ€è¦ä¸€å®šæ—¶é—´ã€‚ä½†å¯ä»¥çœ‹åˆ°ç¼–è¯‘å®Œæˆåï¼Œæ‰§è¡Œä»¿çœŸçš„é€Ÿåº¦æ˜¯éå¸¸å¿«çš„ã€‚

æˆ‘ä»¬å¯ä»¥åœ¨é¡¹ç›®çš„ `simWorkspace` ç›®å½•ä¸‹æŸ¥çœ‹ä»¿çœŸç»“æœã€‚å¤šæ•°æ–‡ä»¶éƒ½æ˜¯ä¸­é—´äº§ç‰©ï¼Œæˆ‘ä»¬ä¸éœ€è¦å…³å¿ƒï¼Œæœ€é‡è¦çš„æ˜¯ `test.vcd` æ–‡ä»¶ï¼Œå®ƒå°±æ˜¯æˆ‘ä»¬ä»¿çœŸäº§ç”Ÿçš„æ³¢å½¢å›¾ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ VSCode çš„ [WaveTrace](https://www.wavetrace.io) æ’ä»¶åœ¨ VSCode ä¸­ç›´æ¥æ‰“å¼€æ³¢å½¢å›¾ï¼š

![WaveTrace](wave-trace.png)

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒWaveTrace æ˜¯ä»˜è´¹åº”ç”¨ï¼Œä¸ä»˜è´¹æ—¶æœ€å¤šåªèƒ½åŒæ—¶æŸ¥çœ‹ 8 ä¸ªä¿¡å·ã€‚å¦ä¸€ä¸ªå¯é€‰çš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨ [GTKWave](https://gtkwave.sourceforge.net)ï¼Œå®ƒä¸ä»…å…è´¹è€Œä¸”æä¾›äº†æ›´å¤šå¼ºå¤§çš„åŠŸèƒ½ï¼Œåå¤„æ˜¯ç•Œé¢æ¯”è¾ƒå¤å¤ï¼Œä¸æ˜“ä½¿ç”¨ã€‚

ä¸Šé¢æ˜¯ä»¿çœŸæˆåŠŸçš„æƒ…å½¢ã€‚æˆ‘ä»¬å¯ä»¥æ•…æ„å°†ä»£ç æ”¹é”™æ¥æµ‹è¯•ä»¿çœŸçš„æ•ˆæœï¼š

**Counter.scala**

```diff
--- a/spinal/lab/lab2/Counter.scala
+++ b/spinal/lab/lab2/Counter.scala
@@ -11,7 +11,7 @@ class Counter extends Component {
 
     val counter = Reg(UInt(4 bits)) init(0) simPublic()
     when (io.trigger) {
-        counter := counter +| 1
+        counter := counter + 1
     }
     io.count := counter
 }
```

è¿è¡Œä»¿çœŸï¼ŒæŠ¥é”™ï¼š

```ini
[46/46] cod.runMain 
[Runtime] SpinalHDL v1.9.4    git head : 270018552577f3bb8e5339ee2583c9c22d324215
[Runtime] JVM max memory : 4096.0MiB
[Runtime] Current date : 2024.05.05 00:10:07
[Progress] at 0.000 : Elaborate components
[Progress] at 0.451 : Checks and transforms
[Progress] at 0.511 : Generate Verilog
[Done] at 0.564
[Progress] Simulation workspace in /Users/abmfy/Code/cod23-grp04/./simWorkspace/Lab2Top
[Progress] Verilator compilation started
[Progress] Verilator compilation done in 3002.138 ms
[Progress] Start Lab2Top test simulation with seed 420213187
[Error] Simulation failed at time=3370000
Exception in thread "main" java.lang.AssertionError: assertion failed: Got 0, expected 15
        at scala.Predef$.assert(Predef.scala:223)
        at spinal.core.package$.assert(core.scala:500)
        at cod.lab2.TestLab2$.$anonfun$new$4(Top.scala:49)
        at scala.collection.immutable.Range.foreach$mVc$sp(Range.scala:158)
        at cod.lab2.TestLab2$.$anonfun$new$3(Top.scala:39)
        at cod.lab2.TestLab2$.$anonfun$new$3$adapted(Top.scala:31)
        at spinal.core.sim.SimCompiled.$anonfun$doSimApi$2(SimBootstraps.scala:608)
        at spinal.sim.SimManager.threadBody$1(SimManager.scala:230)
        at spinal.sim.SimManager.$anonfun$run$1(SimManager.scala:233)
        at spinal.sim.SimThread.$anonfun$jvmThread$1(SimThread.scala:93)
        at spinal.sim.JvmThread.run(SimManager.scala:51)
1 targets failed
cod.runMain subprocess failed
```

æ­¤æ—¶å°±å¯ä»¥æ ¹æ®æ³¢å½¢è¿›è¡Œçº é”™ä¸è°ƒè¯•äº†ã€‚

SpinalHDL ä¸ Verilator ç»“åˆå¯ä»¥å®ç°å‘½ä»¤å¼çš„ä»¿çœŸï¼Œè¿™æ ·æˆ‘ä»¬æ¯æ¬¡ä¿®æ”¹ä»£ç åå³å¯é€šè¿‡è„šæœ¬æµ‹è¯•å…¨éƒ¨ä»¿çœŸæµ‹ä¾‹ï¼Œè¿›è¡Œå¿«é€Ÿè¿­ä»£å’ŒéªŒè¯ã€‚

### è¿è¡Œè„šæœ¬

ä¸Šé¢è¿è¡Œæ—¶æ‰§è¡Œçš„å‘½ä»¤å¯èƒ½æ˜¾å¾—è¾ƒä¸ºå†—é•¿ã€‚Mill æä¾›äº†ä¸°å¯Œçš„é…ç½®åŠŸèƒ½ï¼Œåœ¨ `build.sc` ä¸­å¯ä»¥ä»»æ„è‡ªå®šä¹‰è¿è¡Œè„šæœ¬ï¼Œå› æ­¤æˆ‘ä»¬å®Œå…¨å¯ä»¥å®šä¹‰ä¸€äº›ç®€å•çš„åˆ«åæ¥ç®€åŒ–è¿è¡Œï¼š

**build.sc**

```scala
object cod extends SbtModule { /* ... */ }

def runLab(lab: String) = cod.runMain(s"cod.lab$lab.GenerateLab$lab")
def testLab(lab: String) = cod.runMain(s"cod.lab$lab.TestLab$lab")
```

è¿™æ ·ï¼Œé€šè¿‡ `mill runLab 2` ä¸ `mill testLab 2` å³å¯åˆ†åˆ«æ‰§è¡Œä»£ç ç”Ÿæˆä¸ä»¿çœŸã€‚

## ä¸‹ä¸€æ­¥...

åˆ°ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»æˆåŠŸç”¨ SpinalHDL æ­å»ºèµ·æ¥ç»„æˆåŸç†å®éªŒçš„åŸºæœ¬æ¡†æ¶ï¼Œå¹¶ä¸”ç”¨ Verilator æˆåŠŸè¿è¡Œäº†ä»¿çœŸã€‚å°½ç®¡æˆ‘ä»¬ç›®å‰åªå®Œæˆäº†å®éªŒ 2ï¼Œä½†çœ‹èµ·æ¥æœ‰äº†æ¡†æ¶ï¼Œåé¢è¦åšçš„åªæ˜¯ç»§ç»­æ·»ç –åŠ ç“¦...? ç„¶è€Œï¼Œå®é™…ä¸Šåé¢è¿˜æœ‰ä¸å°‘éº»çƒ¦çš„äº‹æƒ…ï¼š

- å®éªŒ 4 éœ€è¦ç”¨åˆ° SRAMï¼Œè€Œå®ƒçš„ç¡¬ä»¶ä»¿çœŸæ¨¡å‹å«æœ‰æ—¶é—´å»¶è¿Ÿï¼ŒVerilator æ— æ³•å¤„ç†ï¼›
- å®éªŒ 5 éœ€è¦ç”¨åˆ° UART ä¸²å£ï¼Œæˆ‘ä»¬è¦å¦‚ä½•åœ¨ä»¿çœŸä¸­ä¸ä¸²å£è¿›è¡Œäº¤äº’å‘¢ï¼Ÿ
- å¦‚æœè¦è¿›è¡Œ uCore å¯åŠ¨ç­‰é•¿æ—¶é—´çš„ä»¿çœŸï¼Œä¿å­˜çš„æ³¢å½¢å¤ªå¤§ç»™å‚¨å­˜ç©ºé—´å’Œä»¿çœŸé€Ÿåº¦éƒ½å¸¦æ¥äº†æŒ‘æˆ˜ï¼Œè¯¥å¦‚ä½•è§£å†³ï¼Ÿ

æˆ‘ä»¬åœ¨æœ¬ç³»åˆ—çš„åç»­æ–‡ç« å°†é™†ç»­è§£ç­”è¿™äº›é—®é¢˜ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬è¿˜ä¼šä»‹ç»è®¸å¤š SpinalHDL æä¾›çš„æ–¹ä¾¿åŠŸèƒ½ï¼Œå¯æå¤§æå‡å¼€å‘ä½“éªŒï¼š

- çŠ¶æ€æœºã€‚æœ‰äº†å®ƒå†ä¹Ÿä¸ç”¨æ‰‹æ“ä¸‰æ®µå¼çŠ¶æ€æœºäº†ï¼

- ç»§æ‰¿ã€‚é€šè¿‡ç»§æ‰¿ï¼Œå¯ä»¥å®ç°ä¸€äº›é‡å¤é€»è¾‘çš„ç®€åŒ–ï¼Œä¾‹å¦‚å¤šæ•°æ§åˆ¶çŠ¶æ€å¯„å­˜å™¨ (CSR, Control Status Register) çš„é€»è¾‘æ˜¯ç›¸ä¼¼çš„ï¼Œå¯ä»¥é€šè¿‡ç»§æ‰¿ç®€åŒ–é€»è¾‘ã€‚

- é›†åˆã€‚åˆ©ç”¨ Scala çš„é›†åˆä¸ SpinalHDL çš„ä»£ç ç”ŸæˆåŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥æ–¹ä¾¿åœ°æ“ä½œä¸€ç³»åˆ—æ¨¡å—å’Œä¿¡å·ä¹‹é—´çš„è¿æ¥ã€‚è¿˜è®°å¾—æœ¬æ–‡å¼€å¤´æåˆ°çš„å¤šè·¯å¤ç”¨å™¨çš„æ¥çº¿ä¾‹å­å—ï¼Ÿåœ¨ SpinalHDL ä¸­ï¼Œå®ç° [å¤–è®¾æ§åˆ¶ç”µè·¯è®¾è®¡](https://lab.cs.tsinghua.edu.cn/cod-lab-docs/labs/lab6/soc/#_2) ä¸­æåˆ°çš„å¤æ‚äº¤å‰è¿æ¥çš„ä»£ç å¦‚ä¸‹ï¼š

    ```scala
    for ((mux, i) <- muxes.zipWithIndex; (arbiter, j) <- arbiters.zipWithIndex) {
        mux.io.slaves(j) <> arbiter.io.masters(i)
    }
    ```

å¸Œæœ›ç¬”è€…ä¹‹åä¸è¦å’•å’•ï¼Œè‡³å°‘åœ¨å®éªŒå¼€å§‹å‰æŠŠè¿™ä¸€ç³»åˆ—å†™å®Œ () ä¹Ÿé¢„ç¥å¤§å®¶åœ¨ç»„æˆåŸç†å®éªŒä¸­ç©å¾—å¼€å¿ƒï¼
